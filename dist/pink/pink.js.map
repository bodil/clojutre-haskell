{"version":3,"sources":["webpack:///pink.js","webpack:///webpack/bootstrap 2f0040630425f61b8dde","webpack:///./slides.js","webpack:///../pink/lib/events.es6","webpack:///@traceur/generated/TemplateParser/2","webpack:///@traceur/generated/TemplateParser/5","webpack:///@traceur/generated/TemplateParser/6","webpack:///@traceur/generated/TemplateParser/0","webpack:///../pink/deck.es6","webpack:///@traceur/generated/TemplateParser/4","webpack:///@traceur/generated/TemplateParser/3","webpack:///../pink/modules/background.es6","webpack:///../pink/modules/image.es6","webpack:///../pink/lib/mousetrap.js","webpack:///../pink/lib/seq.js","webpack:///../pink/css/fonts/Helvetica/helvetica.css","webpack:///../pink/css/fonts/Inconsolata/inconsolata.css","webpack:///../pink/css/screen.less","webpack:///../pink/~/hammerjs/hammer.js","webpack:///../pink/~/style-loader/addStyle.js","webpack:///../pink/css/screen.less?30e2","webpack:///../pink/~/traceur/bin/traceur-runtime.js","webpack:///../pink/css/fonts/Helvetica/HelveticaNeueLTStd-Bd.otf","webpack:///../pink/css/fonts/Helvetica/HelveticaNeueLTStd-BdIt.otf","webpack:///../pink/css/fonts/Helvetica/HelveticaNeueLTStd-Md.otf","webpack:///../pink/css/fonts/Helvetica/HelveticaNeueLTStd-MdIt.otf","webpack:///../pink/css/fonts/Inconsolata/Inconsolata-Bold.ttf","webpack:///../pink/css/fonts/Inconsolata/Inconsolata-Regular.ttf","webpack:///../pink/css/doge.svg","webpack:///../pink/css/red-doge.svg","webpack:///../pink/~/webpack/~/node-libs-browser/~/process/browser.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","Pink","background","image","getPrefix","cachedPrefix","regex","elem","document","body","$prop","style","undefined","prop","test","match","$traceurRuntime","toProperty","vendorPrefix","cachedEvents","hasOwnProperty","vp","toLowerCase","pp","setProperty","on","emitter","eventName","handler","context","bind","addEventListener","once","wrapper","onceHandler","event","removeEventListener","until","untilHandler","off","Deck","container","deckModules","isFragment","node","classList","contains","fragmentSlide","nodeName","parentNode","applyFragment","from","to","f","$i","i","stream","$__0","this","typeof","querySelector","slides","seq","toArray","querySelectorAll","currentSlide","currentItem","flatMap","slide","concat","forEach","children","childNodes","createElement","add","child","removeChild","appendChild","deactivateSlide","remove","activateSlide","cleanupModules","activateModules","activateItem","item","itemSlide","length","window","location","hash","nextItem","previousItem","prevItem","initModules","mod","slideData","dataset","deckData","mods","arg","push","_deck_modules","activate","stabiliseModules","stabilise","cleanup","transitionEnd","e","target","rescale","screenw","innerWidth","screenh","innerHeight","targetw","targeth","targetScale","Math","min","zoom","events","binding","callback","mousetrap","setTimeout","exec","parseInt","global","Background","url","preload","src","backgroundImage","Image","_addEvent","object","type","attachEvent","_characterFromEvent","character","String","fromCharCode","which","shiftKey","_MAP","_KEYCODE_MAP","_modifiersMatch","modifiers1","modifiers2","sort","join","_resetSequences","doNotReset","key","activeSequences","_sequenceLevels","_nextExpectedAction","_getMatches","modifiers","sequenceName","combination","level","matches","action","_callbacks","_isModifier","metaKey","ctrlKey","deleteCombo","combo","deleteSequence","splice","_eventModifiers","altKey","_preventDefault","preventDefault","returnValue","_stopPropagation","stopPropagation","cancelBubble","_fireCallback","sequence","Mousetrap","stopCallback","srcElement","_handleKey","callbacks","maxLevel","processedSequenceCallback","max","ignoreThisKeypress","_ignoreNextKeypress","_handleKeyEvent","keyCode","_ignoreNextKeyup","handleKey","_resetSequenceTimer","clearTimeout","_resetTimer","_getReverseMap","_REVERSE_MAP","_pickBestAction","_bindSequence","keys","_increaseSequence","nextAction","_callbackAndReset","isFinal","wrappedCallback","_getKeyInfo","_bindSingle","_keysFromString","split","_SPECIAL_ALIASES","_SHIFT_MAP","_directMap","replace","info","_bindMultiple","combinations",8,9,13,16,17,18,20,27,32,33,34,35,36,37,38,39,40,45,46,91,93,224,106,107,109,110,111,186,187,188,189,190,191,192,219,220,221,222,"~","!","@","#","$","%","^","&","*","(",")","_","+",":","\"","<",">","?","|","option","command","return","escape","navigator","platform","Array","unbind","trigger","reset","element","className","indexOf","tagName","isContentEditable","copyProps","indexable","out","l","merge","obj1","arguments","slice","reduce","acc","next","__WEBPACK_AMD_DEFINE_RESULT__","setup","Hammer","READY","Event","determineEventTypes","Utils","each","gestures","gesture","Detection","register","onTouch","DOCUMENT","EVENT_MOVE","detect","EVENT_END","options","Instance","VERSION","defaults","stop_browser_behavior","userSelect","touchAction","touchCallout","contentZooming","userDrag","tapHighlightColor","HAS_POINTEREVENTS","pointerEnabled","msPointerEnabled","HAS_TOUCHEVENTS","MOBILE_REGEX","NO_MOUSEEVENTS","userAgent","EVENT_TYPES","UPDATE_VELOCITY_INTERVAL","DIRECTION_DOWN","DIRECTION_LEFT","DIRECTION_UP","DIRECTION_RIGHT","POINTER_MOUSE","POINTER_TOUCH","POINTER_PEN","EVENT_START","plugins","utils","extend","dest","obj","iterator","o","inStr","needle","hasParent","parent","getCenter","touches","pageX","pageY","clientX","clientY","touch","apply","getVelocity","delta_time","delta_x","delta_y","x","abs","y","getAngle","touch1","touch2","atan2","PI","getDirection","getDistance","sqrt","getScale","start","end","getRotation","isVertical","direction","toggleDefaultBehavior","css_props","toggle","vendor","value","substring","toUpperCase","false_fn","onselectstart","ondragstart","self","enabled","eventStartHandler","ev","startDetect","eventHandlers","prototype","eh","eventData","createEvent","initEvent","dispatchEvent","enable","state","dispose","unbindDom","last_move_event","should_detect","touch_triggered","bindDom","types","eventType","bindDomOnTouch","srcEventType","count_touches","PointerEvent","updatePointer","collectEventData","getTouchList","getEvents","identifier","pointerType","matchType","center","timeStamp","Date","now","srcEvent","preventManipulation","stopDetect","pointers","touchlist","pointer","pointerEvent","pointerId","Object","pt","detection","current","previous","stopped","inst","startEvent","lastEvent","lastVelocityEvent","velocity","name","extendEventData","inst_options","getVelocityData","cur","velocityEv","velocityX","velocityY","getInterimData","angle","interimAngle","interimDirection","startEv","deltaTime","deltaX","deltaY","distance","scale","rotation","index","a","b","Drag","drag_min_distance","correct_for_drag_min_distance","drag_max_touches","drag_block_horizontal","drag_block_vertical","drag_lock_to_axis","drag_lock_min_distance","triggered","startCenter","factor","drag_locked_to_axis","last_direction","is_vertical","Hold","hold_timeout","hold_threshold","timer","Release","Infinity","Swipe","swipe_min_touches","swipe_max_touches","swipe_velocity","Tap","tap_max_touchtime","tap_max_distance","tap_always","doubletap_distance","doubletap_interval","has_moved","prev","since_prev","did_doubletap","moved","Touch","prevent_default","prevent_mouseevents","Transform","transform_min_scale","transform_min_rotation","transform_always_block","transform_within_instance","scale_threshold","rotation_threshold","cssCode","head","styleElement","getElementsByTagName","styleSheet","cssText","createTextNode","process","nonEnum","configurable","enumerable","writable","newUniqueString","floor","random","counter","isSymbol","symbol","SymbolValue","typeOf","v","Symbol","description","TypeError","$defineProperty","symbolDataProperty","symbolInternalProperty","symbolDescriptionProperty","$freeze","symbolValues","getOwnPropertyNames","rv","names","$getOwnPropertyNames","getOwnPropertyDescriptor","$getOwnPropertyDescriptor","getOwnPropertySymbols","$hasOwnProperty","getOption","traceur","sym","desc","defineProperty","descriptor","$create","polyfillObject","is","left","right","assign","source","props","mixin","method","exportStar","j","get","toObject","$TypeError","$Object","spread","k","valueToSpread","getPropertyDescriptor","result","$getPrototypeOf","superDescriptor","homeObject","proto","superCall","args","superGet","superSet","set","getDescriptors","descriptors","createClass","ctor","staticObject","superClass","__proto__","getProtoParent","$defineProperties","defaultSuperCall","addIterator","GeneratorContext","GState","ST_NEWBORN","storedException","finallyFallThrough","sent","tryStack_","getNextOrThrow","ctx","moveNext","ST_EXECUTING","Error","ST_CLOSED","ST_SUSPENDED","done","generatorWrap","innerFunction","getMoveNext","throw","AsyncFunctionContext","err","Promise","resolve","reject","asyncWrap","createCallback","newState","createErrback","ex","last","END_STATE","catch","finally","setupGlobals","create","defineProperties","freeze","getPrototypeOf","toString","symbolValue","valueOf","pushTry","catchState","finallyState","popTry","pop","buildFromEncodedParts","opt_scheme","opt_userInfo","opt_domain","opt_port","opt_path","opt_queryData","opt_fragment","uri","splitRe","removeDotSegments","path","leadingSlash","trailingSlash","segments","up","pos","segment","unshift","joinAndCanonicalizePath","parts","ComponentIndex","PATH","g","SCHEME","USER_INFO","DOMAIN","PORT","QUERY_DATA","FRAGMENT","canonicalizeUrl","resolveUrl","base","baseParts","lastIndexOf","isAbsolute","RegExp","getUncoatedModuleInstantiator","ModuleStore","normalize","moduleInstantiators","Module","uncoatedModule","isLive","coatedModule","getter","liveModuleSentinel","descr","preventExtensions","baseURL","$__2","href","UncoatedModuleEntry","value_","UncoatedModuleInstantiator","func","$UncoatedModuleInstantiator","getUncoatedModule","moduleInstances","refererName","normalizedName","moduleInstance",{"end":{"file":"pink.js","comments_before":[],"nlb":false,"endpos":114321,"pos":114314,"col":9,"line":3665,"value":"baseURL","type":"name","_comments_dumped":true},"start":{"file":"pink.js","comments_before":[],"nlb":false,"endpos":114321,"pos":114314,"col":9,"line":3665,"value":"baseURL","type":"name","_comments_dumped":true},"name":"baseURL"},"registerModule","bundleStore","deps","execute","getAnonymousModule","getForTesting","testingPrefix_","some","System","getModuleImpl","instantiator","toUint32","createArrayIterator","array","kind","ArrayIterator","iteratorObject_","arrayIteratorNextIndex_","arrayIterationKind_","createIteratorResultObject","entries","ARRAY_ITERATOR_KIND_ENTRIES","ARRAY_ITERATOR_KIND_KEYS","values","ARRAY_ITERATOR_KIND_VALUES","$__4","$__5","itemKind","useNextTick","nextTick","flush","useMutationObserver","iterations","observer","BrowserMutationObserver","observe","characterData","data","useSetTimeout","queue","tuple","scheduleFlush","$__default","browserGlobal","MutationObserver","WebKitMutationObserver","isPromise","status_","chain","promise","onResolve","onReject","deferred","getDeferred","constructor","onResolve_","onReject_","promiseReact","C","promiseResolve","promiseDone","promiseReject","r","status","reactions","async","promiseCoerce","then","thenableSymbol","default","resolver","$__6","cast","all","count","resolutions","race","startsWith","search","string","$toString","stringLength","searchString","position","Number","isNaN","$indexOf","endsWith","searchLength","$lastIndexOf","repeat","n","RangeError","codePointAt","size","second","first","charCodeAt","raw","callsite","len","s","fromCodePoint","highSurrogate","lowSurrogate","codeUnits","codePoint","isFinite","maybeDefineMethod","maybeAddFunctions","functions","polyfillPromise","polyfillString","polyfillArray","polyfill","$__9","noop","canSetImmediate","setImmediate","canPost","postMessage","fn","shift","title","browser","env","argv","addListener","removeListener","removeAllListeners","emit","cwd","chdir"],"mappings":"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","file":"pink.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"dist/pink/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Pink = __webpack_require__(2);\n\t\n\tnew Pink(\"#slides\", {\n\t  \"background\": __webpack_require__(3),\n\t  \"image\": __webpack_require__(4)\n\t});\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __moduleName = (void 0);\n\tvar cachedPrefix = null;\n\tfunction getPrefix() {\n\t  if (cachedPrefix)\n\t    return cachedPrefix;\n\t  var regex = /^(Moz|Webkit|Khtml|O|ms|Icab)(?=[A-Z])/;\n\t  var elem = document.body;\n\t  for (var $prop in elem.style) {\n\t    try {\n\t      throw undefined;\n\t    } catch (prop) {\n\t      prop = $prop;\n\t      if (regex.test(prop)) {\n\t        return cachedPrefix = prop.match(regex)[$traceurRuntime.toProperty(0)];\n\t      }\n\t    }\n\t  }\n\t  if ($traceurRuntime.toProperty(\"WebkitOpacity\") in elem.style) {\n\t    return cachedPrefix = \"Webkit\";\n\t  }\n\t  if ($traceurRuntime.toProperty(\"KhtmlOpacity\") in elem.style) {\n\t    return cachedPrefix = \"Khtml\";\n\t  }\n\t  return cachedPrefix = \"\";\n\t}\n\tvar cachedEvents = {};\n\tfunction vendorPrefix(prop) {\n\t  if (cachedEvents.hasOwnProperty(prop))\n\t    return cachedEvents[$traceurRuntime.toProperty(prop)];\n\t  var vp = getPrefix().toLowerCase();\n\t  var pp = (vp) ? (vp + prop) : prop.toLowerCase();\n\t  $traceurRuntime.setProperty(cachedEvents, prop, pp);\n\t  return pp;\n\t}\n\tfunction on(emitter, eventName, handler, context) {\n\t  handler = context ? handler.bind(context) : handler;\n\t  emitter.addEventListener(eventName, handler);\n\t  return handler;\n\t}\n\tfunction once(emitter, eventName, handler, context) {\n\t  handler = context ? handler.bind(context) : handler;\n\t  var wrapper = function onceHandler(event) {\n\t    emitter.removeEventListener(eventName, onceHandler);\n\t    handler(event);\n\t  };\n\t  emitter.addEventListener(eventName, wrapper);\n\t  return wrapper;\n\t}\n\tfunction until(emitter, eventName, handler, context) {\n\t  handler = context ? handler.bind(context) : handler;\n\t  var wrapper = function untilHandler(event) {\n\t    if (handler(event))\n\t      emitter.removeEventListener(eventName, untilHandler);\n\t  };\n\t  emitter.addEventListener(eventName, wrapper);\n\t  return wrapper;\n\t}\n\tfunction off(emitter, eventName, handler) {\n\t  emitter.removeEventListener(eventName, handler);\n\t}\n\tmodule.exports = {\n\t  on: on,\n\t  once: once,\n\t  until: until,\n\t  off: off,\n\t  vendorPrefix: vendorPrefix\n\t};\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __moduleName = (void 0);\n\twindow.global = window;\n\t__webpack_require__(13);\n\t__webpack_require__(12);\n\tvar mousetrap = __webpack_require__(5);\n\tvar hammer = __webpack_require__(10);\n\tvar events = __webpack_require__(1);\n\tvar seq = __webpack_require__(6);\n\tfunction Deck(container, deckModules) {\n\t  var $__0 = this;\n\t  if ((typeof container === 'undefined' ? 'undefined' : $traceurRuntime.typeof(container)) === \"string\") {\n\t    container = document.querySelector(container);\n\t  }\n\t  var slides = seq.toArray(container.querySelectorAll(\"section\"));\n\t  this.currentSlide = null;\n\t  this.currentItem = null;\n\t  var stream = seq.flatMap((function(slide) {\n\t    return [slide].concat(seq.toArray(slide.querySelectorAll(\".fragment\")));\n\t  }), slides);\n\t  function isFragment(node) {\n\t    return node.classList.contains(\"fragment\");\n\t  }\n\t  function fragmentSlide(node) {\n\t    if (isFragment(node)) {\n\t      while (node.nodeName !== \"SECTION\") {\n\t        node = node.parentNode;\n\t      }\n\t    }\n\t    return node;\n\t  }\n\t  slides.forEach((function(slide) {\n\t    var children = seq.toArray(slide.childNodes);\n\t    var container = document.createElement(\"div\");\n\t    container.classList.add(\"slideContainer\");\n\t    children.forEach((function(child) {\n\t      slide.removeChild(child);\n\t      container.appendChild(child);\n\t    }));\n\t    slide.appendChild(container);\n\t  }));\n\t  this.deactivateSlide = (function(slide) {\n\t    if (slide.classList.contains(\"current\")) {\n\t      slide.classList.add(\"out\");\n\t      slide.classList.remove(\"current\");\n\t    }\n\t    $__0.currentSlide = null;\n\t  });\n\t  this.activateSlide = (function(slide) {\n\t    if (slide.classList.contains(\"out\")) {\n\t      $__0.cleanupModules(slide);\n\t      slide.classList.remove(\"out\");\n\t    }\n\t    if ($__0.currentSlide !== null)\n\t      $__0.deactivateSlide($__0.currentSlide);\n\t    $__0.currentSlide = slide;\n\t    $__0.activateModules(slide);\n\t    slide.classList.add(\"current\");\n\t    slide.classList.add(\"in\");\n\t  });\n\t  function applyFragment(from, to, f) {\n\t    var node;\n\t    {\n\t      try {\n\t        throw undefined;\n\t      } catch ($i) {\n\t        $i = from;\n\t        for (; $i <= to; $i++) {\n\t          try {\n\t            throw undefined;\n\t          } catch (i) {\n\t            i = $i;\n\t            try {\n\t              node = stream[$traceurRuntime.toProperty(i)];\n\t              if (isFragment(node)) {\n\t                f(node);\n\t              }\n\t            } finally {\n\t              $i = i;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t  this.activateItem = (function(item) {\n\t    var itemSlide = fragmentSlide(stream[$traceurRuntime.toProperty(item)]);\n\t    if ($__0.currentItem !== null) {\n\t      if ($__0.currentItem < item) {\n\t        applyFragment($__0.currentItem, item, (function(node) {\n\t          return node.classList.add(\"active\");\n\t        }));\n\t      } else if ($__0.currentItem > item) {\n\t        applyFragment(item + 1, $__0.currentItem, (function(node) {\n\t          return node.classList.remove(\"active\");\n\t        }));\n\t      }\n\t    } else {\n\t      applyFragment(0, item, (function(node) {\n\t        return node.classList.add(\"active\");\n\t      }));\n\t      applyFragment(item + 1, stream.length - 1, (function(node) {\n\t        return node.classList.remove(\"active\");\n\t      }));\n\t    }\n\t    $__0.currentItem = item;\n\t    if ($__0.currentSlide !== itemSlide) {\n\t      $__0.activateSlide(itemSlide);\n\t    }\n\t    window.location.hash = \"\" + $__0.currentItem;\n\t  });\n\t  this.nextItem = (function() {\n\t    var nextItem = $__0.currentItem !== null ? $__0.currentItem + 1 : 0;\n\t    if (nextItem >= stream.length)\n\t      nextItem = stream.length - 1;\n\t    if (nextItem !== $__0.currentItem)\n\t      $__0.activateItem(nextItem);\n\t  });\n\t  this.previousItem = (function() {\n\t    var prevItem = $__0.currentItem !== null ? $__0.currentItem - 1 : 0;\n\t    if (prevItem < 0)\n\t      prevItem = 0;\n\t    if (prevItem !== $__0.currentItem)\n\t      $__0.activateItem(prevItem);\n\t  });\n\t  this.initModules = (function(slide) {\n\t    var slideData = slide.dataset,\n\t        deckData = container.dataset;\n\t    var mods = [],\n\t        mod;\n\t    for (mod in deckModules) {\n\t      if (deckModules.hasOwnProperty(mod)) {\n\t        try {\n\t          throw undefined;\n\t        } catch (arg) {\n\t          arg = slideData.hasOwnProperty(mod) ? slideData[$traceurRuntime.toProperty(mod)] : deckData.hasOwnProperty(mod) ? deckData[$traceurRuntime.toProperty(mod)] : null;\n\t          if (arg)\n\t            mods.push(new deckModules[$traceurRuntime.toProperty(mod)](slide, arg));\n\t        }\n\t      }\n\t    }\n\t    slide._deck_modules = mods;\n\t  });\n\t  this.activateModules = (function(slide) {\n\t    slide._deck_modules.forEach((function(mod) {\n\t      return mod.activate && mod.activate();\n\t    }));\n\t  });\n\t  this.stabiliseModules = (function(slide) {\n\t    slide._deck_modules.forEach((function(mod) {\n\t      return mod.stabilise && mod.stabilise();\n\t    }));\n\t  });\n\t  this.cleanupModules = (function(slide) {\n\t    slide._deck_modules.forEach((function(mod) {\n\t      return mod.cleanup && mod.cleanup();\n\t    }));\n\t  });\n\t  this.transitionEnd = (function(e) {\n\t    var slide = e.target;\n\t    if (slide.classList.contains(\"out\")) {\n\t      slide.classList.remove(\"out\");\n\t      $__0.cleanupModules(slide);\n\t    } else if (slide.classList.contains(\"in\")) {\n\t      slide.classList.remove(\"in\");\n\t      $__0.stabiliseModules(slide);\n\t    }\n\t  });\n\t  this.rescale = (function() {\n\t    var screenw = window.innerWidth,\n\t        screenh = window.innerHeight;\n\t    var targetw = 1280,\n\t        targeth = 720;\n\t    var targetScale = Math.min(screenw / targetw, screenh / targeth);\n\t    container.style.zoom = targetScale;\n\t  });\n\t  events.on(window, \"resize\", this.rescale, this);\n\t  slides.forEach(((function(slide) {\n\t    return $__0.initModules(slide);\n\t  })).bind(this));\n\t  events.on(container, events.vendorPrefix(\"TransitionEnd\"), this.transitionEnd, this);\n\t  this.bind = (function(binding, callback) {\n\t    mousetrap.bind(binding, callback.bind($__0));\n\t  });\n\t  this.bind([\"pageup\", \"left\"], this.previousItem);\n\t  this.bind([\"pagedown\", \"right\"], this.nextItem);\n\t  setTimeout((function() {\n\t    $__0.rescale();\n\t    var match = /^#(\\d+)$/.exec(window.location.hash);\n\t    if (match) {\n\t      $__0.activateItem(parseInt(match[$traceurRuntime.toProperty(1)], 10));\n\t    } else {\n\t      $__0.nextItem();\n\t    }\n\t  }), 1);\n\t}\n\tmodule.exports = Deck;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __moduleName = (void 0);\n\tvar events = __webpack_require__(1);\n\tfunction Background(slide, url) {\n\t  var $__0 = this;\n\t  var preload = document.createElement(\"img\");\n\t  preload.src = url;\n\t  this.activate = (function() {\n\t    if ($__0.background)\n\t      $__0.background.parentNode.removeChild($__0.background);\n\t    $__0.background = document.createElement(\"div\");\n\t    $__0.background.classList.add(\"background\");\n\t    $__0.background.style.backgroundImage = \"url(\" + url + \")\";\n\t    slide.parentNode.appendChild($__0.background);\n\t    setTimeout(((function() {\n\t      $__0.background.classList.add(\"active\");\n\t    })).bind($__0), 1);\n\t  });\n\t  this.cleanup = (function() {\n\t    events.once($__0.background, events.vendorPrefix(\"TransitionEnd\"), (function() {\n\t      $__0.background.parentNode.removeChild($__0.background);\n\t      $__0.background = null;\n\t    }), $__0);\n\t    $__0.background.classList.remove(\"active\");\n\t  });\n\t}\n\tmodule.exports = Background;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __moduleName = (void 0);\n\tfunction Image(slide, url) {\n\t  slide.style.backgroundImage = \"url(\" + url + \")\";\n\t}\n\tmodule.exports = Image;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*global define:false */\n\t/**\n\t * Copyright 2013 Craig Campbell\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t *\n\t * Mousetrap is a simple keyboard shortcut library for Javascript with\n\t * no external dependencies\n\t *\n\t * @version 1.4.6\n\t * @url craig.is/killing/mice\n\t */\n\t/**\n\t * mapping of special keycodes to their corresponding keys\n\t *\n\t * everything in this dictionary cannot use keypress events\n\t * so it has to be here to map to the correct keycodes for\n\t * keyup/keydown events\n\t *\n\t * @type {Object}\n\t */\n\tvar _MAP = {\n\t  8: 'backspace',\n\t  9: 'tab',\n\t  13: 'enter',\n\t  16: 'shift',\n\t  17: 'ctrl',\n\t  18: 'alt',\n\t  20: 'capslock',\n\t  27: 'esc',\n\t  32: 'space',\n\t  33: 'pageup',\n\t  34: 'pagedown',\n\t  35: 'end',\n\t  36: 'home',\n\t  37: 'left',\n\t  38: 'up',\n\t  39: 'right',\n\t  40: 'down',\n\t  45: 'ins',\n\t  46: 'del',\n\t  91: 'meta',\n\t  93: 'meta',\n\t  224: 'meta'\n\t},\n\t\n\t    /**\n\t     * mapping for special characters so they can support\n\t     *\n\t     * this dictionary is only used incase you want to bind a\n\t     * keyup or keydown event to one of these keys\n\t     *\n\t     * @type {Object}\n\t     */\n\t    _KEYCODE_MAP = {\n\t      106: '*',\n\t      107: '+',\n\t      109: '-',\n\t      110: '.',\n\t      111 : '/',\n\t      186: ';',\n\t      187: '=',\n\t      188: ',',\n\t      189: '-',\n\t      190: '.',\n\t      191: '/',\n\t      192: '`',\n\t      219: '[',\n\t      220: '\\\\',\n\t      221: ']',\n\t      222: '\\''\n\t    },\n\t\n\t    /**\n\t     * this is a mapping of keys that require shift on a US keypad\n\t     * back to the non shift equivelents\n\t     *\n\t     * this is so you can use keyup events with these keys\n\t     *\n\t     * note that this will only work reliably on US keyboards\n\t     *\n\t     * @type {Object}\n\t     */\n\t    _SHIFT_MAP = {\n\t      '~': '`',\n\t      '!': '1',\n\t      '@': '2',\n\t      '#': '3',\n\t      '$': '4',\n\t      '%': '5',\n\t      '^': '6',\n\t      '&': '7',\n\t      '*': '8',\n\t      '(': '9',\n\t      ')': '0',\n\t      '_': '-',\n\t      '+': '=',\n\t      ':': ';',\n\t      '\\\"': '\\'',\n\t      '<': ',',\n\t      '>': '.',\n\t      '?': '/',\n\t      '|': '\\\\'\n\t    },\n\t\n\t    /**\n\t     * this is a list of special strings you can use to map\n\t     * to modifier keys when you specify your keyboard shortcuts\n\t     *\n\t     * @type {Object}\n\t     */\n\t    _SPECIAL_ALIASES = {\n\t      'option': 'alt',\n\t      'command': 'meta',\n\t      'return': 'enter',\n\t      'escape': 'esc',\n\t      'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n\t    },\n\t\n\t    /**\n\t     * variable to store the flipped version of _MAP from above\n\t     * needed to check if we should use keypress or not when no action\n\t     * is specified\n\t     *\n\t     * @type {Object|undefined}\n\t     */\n\t    _REVERSE_MAP,\n\t\n\t    /**\n\t     * a list of all the callbacks setup via Mousetrap.bind()\n\t     *\n\t     * @type {Object}\n\t     */\n\t    _callbacks = {},\n\t\n\t    /**\n\t     * direct map of string combinations to callbacks used for trigger()\n\t     *\n\t     * @type {Object}\n\t     */\n\t    _directMap = {},\n\t\n\t    /**\n\t     * keeps track of what level each sequence is at since multiple\n\t     * sequences can start out with the same sequence\n\t     *\n\t     * @type {Object}\n\t     */\n\t    _sequenceLevels = {},\n\t\n\t    /**\n\t     * variable to store the setTimeout call\n\t     *\n\t     * @type {null|number}\n\t     */\n\t    _resetTimer,\n\t\n\t    /**\n\t     * temporary state where we will ignore the next keyup\n\t     *\n\t     * @type {boolean|string}\n\t     */\n\t    _ignoreNextKeyup = false,\n\t\n\t    /**\n\t     * temporary state where we will ignore the next keypress\n\t     *\n\t     * @type {boolean}\n\t     */\n\t    _ignoreNextKeypress = false,\n\t\n\t    /**\n\t     * are we currently inside of a sequence?\n\t     * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n\t     *\n\t     * @type {boolean|string}\n\t     */\n\t    _nextExpectedAction = false;\n\t\n\t/**\n\t * loop through the f keys, f1 to f19 and add them to the map\n\t * programatically\n\t */\n\tfor (var i = 1; i < 20; ++i) {\n\t  _MAP[111 + i] = 'f' + i;\n\t}\n\t\n\t/**\n\t * loop through to map numbers on the numeric keypad\n\t */\n\tfor (i = 0; i <= 9; ++i) {\n\t  _MAP[i + 96] = i;\n\t}\n\t\n\t/**\n\t * cross browser add event method\n\t *\n\t * @param {Element|HTMLDocument} object\n\t * @param {string} type\n\t * @param {Function} callback\n\t * @returns void\n\t */\n\tfunction _addEvent(object, type, callback) {\n\t  if (object.addEventListener) {\n\t    object.addEventListener(type, callback, false);\n\t    return;\n\t  }\n\t\n\t  object.attachEvent('on' + type, callback);\n\t}\n\t\n\t/**\n\t * takes the event and returns the key character\n\t *\n\t * @param {Event} e\n\t * @return {string}\n\t */\n\tfunction _characterFromEvent(e) {\n\t\n\t  // for keypress events we should return the character as is\n\t  if (e.type == 'keypress') {\n\t    var character = String.fromCharCode(e.which);\n\t\n\t    // if the shift key is not pressed then it is safe to assume\n\t    // that we want the character to be lowercase.  this means if\n\t    // you accidentally have caps lock on then your key bindings\n\t    // will continue to work\n\t    //\n\t    // the only side effect that might not be desired is if you\n\t    // bind something like 'A' cause you want to trigger an\n\t    // event when capital A is pressed caps lock will no longer\n\t    // trigger the event.  shift+a will though.\n\t    if (!e.shiftKey) {\n\t      character = character.toLowerCase();\n\t    }\n\t\n\t    return character;\n\t  }\n\t\n\t  // for non keypress events the special maps are needed\n\t  if (_MAP[e.which]) {\n\t    return _MAP[e.which];\n\t  }\n\t\n\t  if (_KEYCODE_MAP[e.which]) {\n\t    return _KEYCODE_MAP[e.which];\n\t  }\n\t\n\t  // if it is not in the special map\n\t\n\t  // with keydown and keyup events the character seems to always\n\t  // come in as an uppercase character whether you are pressing shift\n\t  // or not.  we should make sure it is always lowercase for comparisons\n\t  return String.fromCharCode(e.which).toLowerCase();\n\t}\n\t\n\t/**\n\t * checks if two arrays are equal\n\t *\n\t * @param {Array} modifiers1\n\t * @param {Array} modifiers2\n\t * @returns {boolean}\n\t */\n\tfunction _modifiersMatch(modifiers1, modifiers2) {\n\t  return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n\t}\n\t\n\t/**\n\t * resets all sequence counters except for the ones passed in\n\t *\n\t * @param {Object} doNotReset\n\t * @returns void\n\t */\n\tfunction _resetSequences(doNotReset) {\n\t  doNotReset = doNotReset || {};\n\t\n\t  var activeSequences = false,\n\t      key;\n\t\n\t  for (key in _sequenceLevels) {\n\t    if (doNotReset[key]) {\n\t      activeSequences = true;\n\t      continue;\n\t    }\n\t    _sequenceLevels[key] = 0;\n\t  }\n\t\n\t  if (!activeSequences) {\n\t    _nextExpectedAction = false;\n\t  }\n\t}\n\t\n\t/**\n\t * finds all callbacks that match based on the keycode, modifiers,\n\t * and action\n\t *\n\t * @param {string} character\n\t * @param {Array} modifiers\n\t * @param {Event|Object} e\n\t * @param {string=} sequenceName - name of the sequence we are looking for\n\t * @param {string=} combination\n\t * @param {number=} level\n\t * @returns {Array}\n\t */\n\tfunction _getMatches(character, modifiers, e, sequenceName, combination, level) {\n\t  var i,\n\t      callback,\n\t      matches = [],\n\t      action = e.type;\n\t\n\t  // if there are no events related to this keycode\n\t  if (!_callbacks[character]) {\n\t    return [];\n\t  }\n\t\n\t  // if a modifier key is coming up on its own we should allow it\n\t  if (action == 'keyup' && _isModifier(character)) {\n\t    modifiers = [character];\n\t  }\n\t\n\t  // loop through all callbacks for the key that was pressed\n\t  // and see if any of them match\n\t  for (i = 0; i < _callbacks[character].length; ++i) {\n\t    callback = _callbacks[character][i];\n\t\n\t    // if a sequence name is not specified, but this is a sequence at\n\t    // the wrong level then move onto the next match\n\t    if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n\t      continue;\n\t    }\n\t\n\t    // if the action we are looking for doesn't match the action we got\n\t    // then we should keep going\n\t    if (action != callback.action) {\n\t      continue;\n\t    }\n\t\n\t    // if this is a keypress event and the meta key and control key\n\t    // are not pressed that means that we need to only look at the\n\t    // character, otherwise check the modifiers as well\n\t    //\n\t    // chrome will not fire a keypress if meta or control is down\n\t    // safari will fire a keypress if meta or meta+shift is down\n\t    // firefox will fire a keypress if meta or control is down\n\t    if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\t\n\t      // when you bind a combination or sequence a second time it\n\t      // should overwrite the first one.  if a sequenceName or\n\t      // combination is specified in this call it does just that\n\t      //\n\t      // @todo make deleting its own method?\n\t      var deleteCombo = !sequenceName && callback.combo == combination;\n\t      var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n\t      if (deleteCombo || deleteSequence) {\n\t        _callbacks[character].splice(i, 1);\n\t      }\n\t\n\t      matches.push(callback);\n\t    }\n\t  }\n\t\n\t  return matches;\n\t}\n\t\n\t/**\n\t * takes a key event and figures out what the modifiers are\n\t *\n\t * @param {Event} e\n\t * @returns {Array}\n\t */\n\tfunction _eventModifiers(e) {\n\t  var modifiers = [];\n\t\n\t  if (e.shiftKey) {\n\t    modifiers.push('shift');\n\t  }\n\t\n\t  if (e.altKey) {\n\t    modifiers.push('alt');\n\t  }\n\t\n\t  if (e.ctrlKey) {\n\t    modifiers.push('ctrl');\n\t  }\n\t\n\t  if (e.metaKey) {\n\t    modifiers.push('meta');\n\t  }\n\t\n\t  return modifiers;\n\t}\n\t\n\t/**\n\t * prevents default for this event\n\t *\n\t * @param {Event} e\n\t * @returns void\n\t */\n\tfunction _preventDefault(e) {\n\t  if (e.preventDefault) {\n\t    e.preventDefault();\n\t    return;\n\t  }\n\t\n\t  e.returnValue = false;\n\t}\n\t\n\t/**\n\t * stops propogation for this event\n\t *\n\t * @param {Event} e\n\t * @returns void\n\t */\n\tfunction _stopPropagation(e) {\n\t  if (e.stopPropagation) {\n\t    e.stopPropagation();\n\t    return;\n\t  }\n\t\n\t  e.cancelBubble = true;\n\t}\n\t\n\t/**\n\t * actually calls the callback function\n\t *\n\t * if your callback function returns false this will use the jquery\n\t * convention - prevent default and stop propogation on the event\n\t *\n\t * @param {Function} callback\n\t * @param {Event} e\n\t * @returns void\n\t */\n\tfunction _fireCallback(callback, e, combo, sequence) {\n\t\n\t  // if this event should not happen stop here\n\t  if (Mousetrap.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n\t    return;\n\t  }\n\t\n\t  if (callback(e, combo) === false) {\n\t    _preventDefault(e);\n\t    _stopPropagation(e);\n\t  }\n\t}\n\t\n\t/**\n\t * handles a character key event\n\t *\n\t * @param {string} character\n\t * @param {Array} modifiers\n\t * @param {Event} e\n\t * @returns void\n\t */\n\tfunction _handleKey(character, modifiers, e) {\n\t  var callbacks = _getMatches(character, modifiers, e),\n\t      i,\n\t      doNotReset = {},\n\t      maxLevel = 0,\n\t      processedSequenceCallback = false;\n\t\n\t  // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n\t  for (i = 0; i < callbacks.length; ++i) {\n\t    if (callbacks[i].seq) {\n\t      maxLevel = Math.max(maxLevel, callbacks[i].level);\n\t    }\n\t  }\n\t\n\t  // loop through matching callbacks for this key event\n\t  for (i = 0; i < callbacks.length; ++i) {\n\t\n\t    // fire for all sequence callbacks\n\t    // this is because if for example you have multiple sequences\n\t    // bound such as \"g i\" and \"g t\" they both need to fire the\n\t    // callback for matching g cause otherwise you can only ever\n\t    // match the first one\n\t    if (callbacks[i].seq) {\n\t\n\t      // only fire callbacks for the maxLevel to prevent\n\t      // subsequences from also firing\n\t      //\n\t      // for example 'a option b' should not cause 'option b' to fire\n\t      // even though 'option b' is part of the other sequence\n\t      //\n\t      // any sequences that do not match here will be discarded\n\t      // below by the _resetSequences call\n\t      if (callbacks[i].level != maxLevel) {\n\t        continue;\n\t      }\n\t\n\t      processedSequenceCallback = true;\n\t\n\t      // keep a list of which sequences were matches for later\n\t      doNotReset[callbacks[i].seq] = 1;\n\t      _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n\t      continue;\n\t    }\n\t\n\t    // if there were no sequence matches but we are still here\n\t    // that means this is a regular match so we should fire that\n\t    if (!processedSequenceCallback) {\n\t      _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n\t    }\n\t  }\n\t\n\t  // if the key you pressed matches the type of sequence without\n\t  // being a modifier (ie \"keyup\" or \"keypress\") then we should\n\t  // reset all sequences that were not matched by this event\n\t  //\n\t  // this is so, for example, if you have the sequence \"h a t\" and you\n\t  // type \"h e a r t\" it does not match.  in this case the \"e\" will\n\t  // cause the sequence to reset\n\t  //\n\t  // modifier keys are ignored because you can have a sequence\n\t  // that contains modifiers such as \"enter ctrl+space\" and in most\n\t  // cases the modifier key will be pressed before the next key\n\t  //\n\t  // also if you have a sequence such as \"ctrl+b a\" then pressing the\n\t  // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n\t  //\n\t  // the \"keydown\" is expected when there is a modifier, but the\n\t  // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n\t  // after and that causes the sequence to reset\n\t  //\n\t  // we ignore keypresses in a sequence that directly follow a keydown\n\t  // for the same character\n\t  var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n\t  if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n\t    _resetSequences(doNotReset);\n\t  }\n\t\n\t  _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n\t}\n\t\n\t/**\n\t * handles a keydown event\n\t *\n\t * @param {Event} e\n\t * @returns void\n\t */\n\tfunction _handleKeyEvent(e) {\n\t\n\t  // normalize e.which for key events\n\t  // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n\t  if (typeof e.which !== 'number') {\n\t    e.which = e.keyCode;\n\t  }\n\t\n\t  var character = _characterFromEvent(e);\n\t\n\t  // no character found then stop\n\t  if (!character) {\n\t    return;\n\t  }\n\t\n\t  // need to use === for the character check because the character can be 0\n\t  if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n\t    _ignoreNextKeyup = false;\n\t    return;\n\t  }\n\t\n\t  Mousetrap.handleKey(character, _eventModifiers(e), e);\n\t}\n\t\n\t/**\n\t * determines if the keycode specified is a modifier key or not\n\t *\n\t * @param {string} key\n\t * @returns {boolean}\n\t */\n\tfunction _isModifier(key) {\n\t  return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n\t}\n\t\n\t/**\n\t * called to set a 1 second timeout on the specified sequence\n\t *\n\t * this is so after each key press in the sequence you have 1 second\n\t * to press the next key before you have to start over\n\t *\n\t * @returns void\n\t */\n\tfunction _resetSequenceTimer() {\n\t  clearTimeout(_resetTimer);\n\t  _resetTimer = setTimeout(_resetSequences, 1000);\n\t}\n\t\n\t/**\n\t * reverses the map lookup so that we can look for specific keys\n\t * to see what can and can't use keypress\n\t *\n\t * @return {Object}\n\t */\n\tfunction _getReverseMap() {\n\t  if (!_REVERSE_MAP) {\n\t    _REVERSE_MAP = {};\n\t    for (var key in _MAP) {\n\t\n\t      // pull out the numeric keypad from here cause keypress should\n\t      // be able to detect the keys from the character\n\t      if (key > 95 && key < 112) {\n\t        continue;\n\t      }\n\t\n\t      if (_MAP.hasOwnProperty(key)) {\n\t        _REVERSE_MAP[_MAP[key]] = key;\n\t      }\n\t    }\n\t  }\n\t  return _REVERSE_MAP;\n\t}\n\t\n\t/**\n\t * picks the best action based on the key combination\n\t *\n\t * @param {string} key - character for key\n\t * @param {Array} modifiers\n\t * @param {string=} action passed in\n\t */\n\tfunction _pickBestAction(key, modifiers, action) {\n\t\n\t  // if no action was picked in we should try to pick the one\n\t  // that we think would work best for this key\n\t  if (!action) {\n\t    action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n\t  }\n\t\n\t  // modifier keys don't work as expected with keypress,\n\t  // switch to keydown\n\t  if (action == 'keypress' && modifiers.length) {\n\t    action = 'keydown';\n\t  }\n\t\n\t  return action;\n\t}\n\t\n\t/**\n\t * binds a key sequence to an event\n\t *\n\t * @param {string} combo - combo specified in bind call\n\t * @param {Array} keys\n\t * @param {Function} callback\n\t * @param {string=} action\n\t * @returns void\n\t */\n\tfunction _bindSequence(combo, keys, callback, action) {\n\t\n\t  // start off by adding a sequence level record for this combination\n\t  // and setting the level to 0\n\t  _sequenceLevels[combo] = 0;\n\t\n\t  /**\n\t   * callback to increase the sequence level for this sequence and reset\n\t   * all other sequences that were active\n\t   *\n\t   * @param {string} nextAction\n\t   * @returns {Function}\n\t   */\n\t  function _increaseSequence(nextAction) {\n\t    return function() {\n\t      _nextExpectedAction = nextAction;\n\t      ++_sequenceLevels[combo];\n\t      _resetSequenceTimer();\n\t    };\n\t  }\n\t\n\t  /**\n\t   * wraps the specified callback inside of another function in order\n\t   * to reset all sequence counters as soon as this sequence is done\n\t   *\n\t   * @param {Event} e\n\t   * @returns void\n\t   */\n\t  function _callbackAndReset(e) {\n\t    _fireCallback(callback, e, combo);\n\t\n\t    // we should ignore the next key up if the action is key down\n\t    // or keypress.  this is so if you finish a sequence and\n\t    // release the key the final key will not trigger a keyup\n\t    if (action !== 'keyup') {\n\t      _ignoreNextKeyup = _characterFromEvent(e);\n\t    }\n\t\n\t    // weird race condition if a sequence ends with the key\n\t    // another sequence begins with\n\t    setTimeout(_resetSequences, 10);\n\t  }\n\t\n\t  // loop through keys one at a time and bind the appropriate callback\n\t  // function.  for any key leading up to the final one it should\n\t  // increase the sequence. after the final, it should reset all sequences\n\t  //\n\t  // if an action is specified in the original bind call then that will\n\t  // be used throughout.  otherwise we will pass the action that the\n\t  // next key in the sequence should match.  this allows a sequence\n\t  // to mix and match keypress and keydown events depending on which\n\t  // ones are better suited to the key provided\n\t  for (var i = 0; i < keys.length; ++i) {\n\t    var isFinal = i + 1 === keys.length;\n\t    var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n\t    _bindSingle(keys[i], wrappedCallback, action, combo, i);\n\t  }\n\t}\n\t\n\t/**\n\t * Converts from a string key combination to an array\n\t *\n\t * @param  {string} combination like \"command+shift+l\"\n\t * @return {Array}\n\t */\n\tfunction _keysFromString(combination) {\n\t  if (combination === '+') {\n\t    return ['+'];\n\t  }\n\t\n\t  return combination.split('+');\n\t}\n\t\n\t/**\n\t * Gets info for a specific key combination\n\t *\n\t * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n\t * @param  {string=} action\n\t * @returns {Object}\n\t */\n\tfunction _getKeyInfo(combination, action) {\n\t  var keys,\n\t      key,\n\t      i,\n\t      modifiers = [];\n\t\n\t  // take the keys from this pattern and figure out what the actual\n\t  // pattern is all about\n\t  keys = _keysFromString(combination);\n\t\n\t  for (i = 0; i < keys.length; ++i) {\n\t    key = keys[i];\n\t\n\t    // normalize key names\n\t    if (_SPECIAL_ALIASES[key]) {\n\t      key = _SPECIAL_ALIASES[key];\n\t    }\n\t\n\t    // if this is not a keypress event then we should\n\t    // be smart about using shift keys\n\t    // this will only work for US keyboards however\n\t    if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n\t      key = _SHIFT_MAP[key];\n\t      modifiers.push('shift');\n\t    }\n\t\n\t    // if this key is a modifier then add it to the list of modifiers\n\t    if (_isModifier(key)) {\n\t      modifiers.push(key);\n\t    }\n\t  }\n\t\n\t  // depending on what the key combination is\n\t  // we will try to pick the best event for it\n\t  action = _pickBestAction(key, modifiers, action);\n\t\n\t  return {\n\t    key: key,\n\t    modifiers: modifiers,\n\t    action: action\n\t  };\n\t}\n\t\n\t/**\n\t * binds a single keyboard combination\n\t *\n\t * @param {string} combination\n\t * @param {Function} callback\n\t * @param {string=} action\n\t * @param {string=} sequenceName - name of sequence if part of sequence\n\t * @param {number=} level - what part of the sequence the command is\n\t * @returns void\n\t */\n\tfunction _bindSingle(combination, callback, action, sequenceName, level) {\n\t\n\t  // store a direct mapped reference for use with Mousetrap.trigger\n\t  _directMap[combination + ':' + action] = callback;\n\t\n\t  // make sure multiple spaces in a row become a single space\n\t  combination = combination.replace(/\\s+/g, ' ');\n\t\n\t  var sequence = combination.split(' '),\n\t      info;\n\t\n\t  // if this pattern is a sequence of keys then run through this method\n\t  // to reprocess each pattern one key at a time\n\t  if (sequence.length > 1) {\n\t    _bindSequence(combination, sequence, callback, action);\n\t    return;\n\t  }\n\t\n\t  info = _getKeyInfo(combination, action);\n\t\n\t  // make sure to initialize array if this is the first time\n\t  // a callback is added for this key\n\t  _callbacks[info.key] = _callbacks[info.key] || [];\n\t\n\t  // remove an existing match if there is one\n\t  _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\t\n\t  // add this call back to the array\n\t  // if it is a sequence put it at the beginning\n\t  // if not put it at the end\n\t  //\n\t  // this is important because the way these are processed expects\n\t  // the sequence ones to come first\n\t  _callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n\t    callback: callback,\n\t    modifiers: info.modifiers,\n\t    action: info.action,\n\t    seq: sequenceName,\n\t    level: level,\n\t    combo: combination\n\t  });\n\t}\n\t\n\t/**\n\t * binds multiple combinations to the same callback\n\t *\n\t * @param {Array} combinations\n\t * @param {Function} callback\n\t * @param {string|undefined} action\n\t * @returns void\n\t */\n\tfunction _bindMultiple(combinations, callback, action) {\n\t  for (var i = 0; i < combinations.length; ++i) {\n\t    _bindSingle(combinations[i], callback, action);\n\t  }\n\t}\n\t\n\t// start!\n\t_addEvent(document, 'keypress', _handleKeyEvent);\n\t_addEvent(document, 'keydown', _handleKeyEvent);\n\t_addEvent(document, 'keyup', _handleKeyEvent);\n\t\n\tvar Mousetrap = {\n\t\n\t  /**\n\t   * binds an event to mousetrap\n\t   *\n\t   * can be a single key, a combination of keys separated with +,\n\t   * an array of keys, or a sequence of keys separated by spaces\n\t   *\n\t   * be sure to list the modifier keys first to make sure that the\n\t   * correct key ends up getting bound (the last key in the pattern)\n\t   *\n\t   * @param {string|Array} keys\n\t   * @param {Function} callback\n\t   * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n\t   * @returns void\n\t   */\n\t  bind: function(keys, callback, action) {\n\t    keys = keys instanceof Array ? keys : [keys];\n\t    _bindMultiple(keys, callback, action);\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * unbinds an event to mousetrap\n\t   *\n\t   * the unbinding sets the callback function of the specified key combo\n\t   * to an empty function and deletes the corresponding key in the\n\t   * _directMap dict.\n\t   *\n\t   * TODO: actually remove this from the _callbacks dictionary instead\n\t   * of binding an empty function\n\t   *\n\t   * the keycombo+action has to be exactly the same as\n\t   * it was defined in the bind method\n\t   *\n\t   * @param {string|Array} keys\n\t   * @param {string} action\n\t   * @returns void\n\t   */\n\t  unbind: function(keys, action) {\n\t    return Mousetrap.bind(keys, function() {}, action);\n\t  },\n\t\n\t  /**\n\t   * triggers an event that has already been bound\n\t   *\n\t   * @param {string} keys\n\t   * @param {string=} action\n\t   * @returns void\n\t   */\n\t  trigger: function(keys, action) {\n\t    if (_directMap[keys + ':' + action]) {\n\t      _directMap[keys + ':' + action]({}, keys);\n\t    }\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * resets the library back to its initial state.  this is useful\n\t   * if you want to clear out the current keyboard shortcuts and bind\n\t   * new ones - for example if you switch to another page\n\t   *\n\t   * @returns void\n\t   */\n\t  reset: function() {\n\t    _callbacks = {};\n\t    _directMap = {};\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * should we stop this event before firing off callbacks\n\t   *\n\t   * @param {Event} e\n\t   * @param {Element} element\n\t   * @return {boolean}\n\t   */\n\t  stopCallback: function(e, element) {\n\t\n\t    // if the element has the class \"mousetrap\" then no need to stop\n\t    if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n\t      return false;\n\t    }\n\t\n\t    // stop for input, select, and textarea\n\t    return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n\t  },\n\t\n\t  /**\n\t   * exposes _handleKey publicly so it can be overwritten by extensions\n\t   */\n\t  handleKey: _handleKey\n\t};\n\t\n\tmodule.exports = Mousetrap;\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toArray = module.exports.toArray = function toArray(indexable) {\n\t  var i, out = [], l = indexable.length;\n\t  for (i = 0; i < l; i++) {\n\t    out.push(indexable[i]);\n\t  }\n\t  return out;\n\t}\n\t\n\tmodule.exports.flatMap = function flatMap(f, seq) {\n\t  var i, out = [], l = seq.length;\n\t  for (i = 0; i < l; i++) {\n\t    out = out.concat(f(seq[i]));\n\t  }\n\t  return out;\n\t}\n\t\n\tfunction copyProps(target, src) {\n\t  var prop;\n\t  for (prop in src) {\n\t    if (src.hasOwnProperty(prop)) {\n\t      target[prop] = src[prop];\n\t    }\n\t  }\n\t  return target;\n\t}\n\t\n\tmodule.exports.merge = function merge(obj1) {\n\t  return toArray(arguments).slice(1).reduce(function(acc, next) {\n\t    return copyProps(acc, next);\n\t  }, copyProps({}, obj1));\n\t}\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports =\n\t\t\"@font-face{font-family:'Helvetica Neue LT Std';font-style:normal;font-weight:400;src:local('Helvetica Neue LT Std Regular'),url(\"+__webpack_require__(16)+\") format('opentype')}@font-face{font-family:'Helvetica Neue LT Std';font-style:normal;font-weight:700;src:local('Helvetica Neue LT Std Bold'),url(\"+__webpack_require__(14)+\") format('opentype')}@font-face{font-family:'Helvetica Neue LT Std';font-style:italic;font-weight:400;src:local('Helvetica Neue LT Std Regular Italic'),url(\"+__webpack_require__(17)+\") format('opentype')}@font-face{font-family:'Helvetica Neue LT Std';font-style:italic;font-weight:700;src:local('Helvetica Neue LT Std Bold Italic'),url(\"+__webpack_require__(15)+\") format('opentype')}\";\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports =\n\t\t\"@font-face{font-family:'Inconsolata';font-style:normal;font-weight:400;src:local('Inconsolata'),url(\"+__webpack_require__(19)+\") format('truetype')}@font-face{font-family:'Inconsolata';font-style:normal;font-weight:700;src:local('Inconsolata Bold'),local('Inconsolata-Bold'),url(\"+__webpack_require__(18)+\") format('truetype')}\";\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports =\n\t\t__webpack_require__(7) +\n\t\t__webpack_require__(8) +\n\t\t\"html,body{border:0;font-family:\\\"Helvetica-Neue\\\",\\\"Helvetica\\\",Arial,sans-serif;line-height:1.5;margin:0;padding:0}div,span,object,iframe,img,table,caption,thead,tbody,tfoot,tr,tr,td,article,aside,canvas,details,figure,hgroup,menu,nav,footer,header,section,summary,mark,audio,video{border:0;margin:0;padding:0}h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,address,cit,code,del,dfn,em,ins,q,samp,small,strong,sub,sup,b,i,hr,dl,dt,dd,ol,ul,li,fieldset,legend,label{border:0;font-size:100%;vertical-align:baseline;margin:0;padding:0}article,aside,canvas,figure,figure img,figcaption,hgroup,footer,header,nav,section,audio,video{display:block}table{border-collapse:separate;border-spacing:0}table caption,table th,table td{text-align:left;vertical-align:middle}a img{border:0}:focus{outline:0}*,*:before,*:after{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}body{color:#222;margin:0;padding:0;border:0;font-family:\\\"Helvetica Neue LT Std\\\";font-size:48pt;line-height:1.2em;visibility:visible}p,a,li,li:before,h1,h2,h3,h4,h5,h6{text-shadow:0 0 .1em rgba(0,0,0,.5)}h1,h2,h3,h4,h5,h6{text-align:center;font-weight:700;background-color:rgba(0,0,0,.1);margin:.4em -100%}h1{font-size:1.6em;padding-top:.25em}h2{font-size:1.4em;padding-top:.3em}h3{font-size:1.2em;padding-top:.3em}h4,h5,h6{font-size:1.1em;padding-top:.3em}strong{letter-spacing:.05em}a{color:#000}em{font-style:normal;text-decoration:underline}.attribution{font-size:.9em}#slides{z-index:1;position:fixed;background:#ccc}#slides,#slides .background{background-size:cover;background-position:50% 50%;width:100%;height:100%;margin:0;padding:0;border:0}#slides .background{z-index:2;position:absolute;opacity:0;-webkit-transition:opacity .3s ease;-moz-transition:opacity .3s ease;transition:opacity .3s ease}#slides .background.active{opacity:1}#slides section{background-color:rgba(255,255,255,.8);background-size:cover;background-position:50% 50%;z-index:10;visibility:hidden;position:absolute;width:80%;height:80%;left:10%;top:10%;margin:0;padding:0 10%;border:0;border-radius:.2em;display:-webkit-box;display:-moz-box;display:box;-webkit-box-pack:center;-webkit-box-align:center;-moz-box-pack:center;-moz-box-align:center;box-pack:center;box-align:center;opacity:0;-webkit-transform:scale(1.25);-webkit-filter:grayscale(100%);-webkit-transition:-webkit-filter .3s ease,-webkit-transform .3s ease,opacity .3s ease;-moz-transform:scale(1.25);-moz-filter:grayscale(100%);-moz-transition:-moz-filter .3s ease,-moz-transform .3s ease,opacity .3s ease;transform:scale(1.25);filter:grayscale(100%);transition:filter .3s ease,transform .3s ease,opacity .3s ease}#slides section .slideContainer{width:100%}#slides section.current,#slides section.out{visibility:visible}#slides section.current{opacity:1;-webkit-filter:grayscale(0);-webkit-transform:scale(1);-moz-filter:grayscale(0);-moz-transform:scale(1);filter:grayscale(0);transform:scale(1)}#slides section.out{-webkit-transform:scale(.75);-moz-transform:scale(.75);transform:scale(.75)}#slides section .fragment{opacity:0;-webkit-transform:scale(1.25);-webkit-filter:grayscale(100%);-webkit-transition:-webkit-filter .3s ease,-webkit-transform .3s ease,opacity .3s ease;-moz-transform:scale(1.25);-moz-filter:grayscale(100%);-moz-transition:-moz-filter .3s ease,-moz-transform .3s ease,opacity .3s ease;transform:scale(1.25);filter:grayscale(100%);transition:filter .3s ease,transform .3s ease,opacity .3s ease}#slides section .fragment.active{opacity:1;-webkit-transform:scale(1);-webkit-filter:grayscale(0);-moz-transform:scale(1);-moz-filter:grayscale(0);transform:scale(1);filter:grayscale(0)}#slides section.editor{left:0;top:0;width:100%;height:100%;border-radius:0;background:0 0}#slides section.editor .editorFrame,#slides section.editor .targetFrame{position:absolute;height:100%;top:0;padding:.5em}#slides section.editor .editorFrame{left:0;width:100%}#slides section.editor.withTargetFrame .editorFrame,#slides section.editor.withTargetFrame .targetFrame{width:50%}#slides section.editor.withTargetFrame .editorFrame{padding-right:0}#slides section.editor.withTargetFrame .targetFrame{left:50%}#slides section.editor .targetFrame iframe{z-index:14;background-color:#444;background-image:url(\"+__webpack_require__(20)+\");background-size:contain;background-repeat:no-repeat;background-position:50% 50%;width:100%;height:100%;margin:0;padding:0}#slides section.editor .loaderFrame{z-index:15;background:#444;width:100%;height:100%;margin:0;padding:0}#slides section.editor .CodeMirror{font-family:\\\"Inconsolata\\\";line-height:1.2em;font-size:.4em}#slides section.editor .CodeMirror,#slides section.editor .loaderFrame,#slides section.editor .targetFrame iframe{box-shadow:0 .1em .2em rgba(0,0,0,.6);border-radius:.1em}#slides section.photo{background-size:contain;background-color:rgba(0,0,0,0);background-repeat:no-repeat}#slides section.white{text-align:center}#slides section.white h1,#slides section.white h2,#slides section.white h3,#slides section.white h4,#slides section.white h5,#slides section.white h6,#slides section.white p,#slides section.white a,#slides section.white li{color:#fff;text-shadow:0 -.05em .1em #000,0 .05em .1em #000,0 .1em .3em #000;background:0 0;font-weight:400}#slides section.align-bottom{-webkit-box-pack:end;-webkit-box-align:end;-moz-box-pack:end;-moz-box-align:end;box-pack:end;box-align:end;padding-bottom:.5em}#slides section.erlang-the-movie h1,#slides section.erlang-the-movie h2,#slides section.erlang-the-movie h3,#slides section.erlang-the-movie h4,#slides section.erlang-the-movie h5,#slides section.erlang-the-movie h6,#slides section.erlang-the-movie p,#slides section.erlang-the-movie a{font-weight:bolder;-webkit-transform:scale(.8,1);-moz-transform:scale(.8,1);transform:scale(.8,1);margin:0}#slides section.erlang-the-movie p{font-size:.9em;margin:0 -6em}.CodeMirror-hints,.CodeMirror-Tern-tooltip{font-family:\\\"Inconsolata\\\";line-height:1.2em;font-size:.5em!important;text-shadow:none}.CodeMirror-hints li,.CodeMirror-Tern-tooltip li{text-shadow:none}.cm-errors{width:1em}.CodeMirror-gutter-wrapper .cm-error{width:1em;height:1em;background:url(\"+__webpack_require__(21)+\");background-size:contain}\";\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v1.0.11 - 2014-05-20\n\t * http://eightmedia.github.io/hammer.js\n\t *\n\t * Copyright (c) 2014 Jorik Tangelder <j.tangelder@gmail.com>;\n\t * Licensed under the MIT license */\n\t\n\t(function(window, undefined) {\n\t  'use strict';\n\t\n\t/**\n\t * Hammer\n\t * use this to create instances\n\t * @param   {HTMLElement}   element\n\t * @param   {Object}        options\n\t * @returns {Hammer.Instance}\n\t * @constructor\n\t */\n\tvar Hammer = function(element, options) {\n\t  return new Hammer.Instance(element, options || {});\n\t};\n\t\n\tHammer.VERSION = '1.0.11';\n\t\n\t// default settings\n\tHammer.defaults = {\n\t  // add styles and attributes to the element to prevent the browser from doing\n\t  // its native behavior. this doesnt prevent the scrolling, but cancels\n\t  // the contextmenu, tap highlighting etc\n\t  // set to false to disable this\n\t  stop_browser_behavior: {\n\t    // this also triggers onselectstart=false for IE\n\t    userSelect       : 'none',\n\t    // this makes the element blocking in IE10> and Chrome 35>, you could experiment with the value\n\t    // see for more options the wiki: https://github.com/EightMedia/hammer.js/wiki\n\t    touchAction      : 'pan-y',\n\t\n\t    touchCallout     : 'none',\n\t    contentZooming   : 'none',\n\t    userDrag         : 'none',\n\t    tapHighlightColor: 'rgba(0,0,0,0)'\n\t  }\n\t\n\t  //\n\t  // more settings are defined per gesture at /gestures\n\t  //\n\t};\n\t\n\t\n\t// detect touchevents\n\tHammer.HAS_POINTEREVENTS = window.navigator.pointerEnabled || window.navigator.msPointerEnabled;\n\tHammer.HAS_TOUCHEVENTS = ('ontouchstart' in window);\n\t\n\t// dont use mouseevents on mobile devices\n\tHammer.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android|silk/i;\n\tHammer.NO_MOUSEEVENTS = Hammer.HAS_TOUCHEVENTS && window.navigator.userAgent.match(Hammer.MOBILE_REGEX);\n\t\n\t// eventtypes per touchevent (start, move, end)\n\t// are filled by Event.determineEventTypes on setup\n\tHammer.EVENT_TYPES = {};\n\t\n\t// interval in which Hammer recalculates current velocity in ms\n\tHammer.UPDATE_VELOCITY_INTERVAL = 16;\n\t\n\t// hammer document where the base events are added at\n\tHammer.DOCUMENT = window.document;\n\t\n\t// define these also as vars, for better minification\n\t// direction defines\n\tvar DIRECTION_DOWN = Hammer.DIRECTION_DOWN = 'down';\n\tvar DIRECTION_LEFT = Hammer.DIRECTION_LEFT = 'left';\n\tvar DIRECTION_UP = Hammer.DIRECTION_UP = 'up';\n\tvar DIRECTION_RIGHT = Hammer.DIRECTION_RIGHT = 'right';\n\t\n\t// pointer type\n\tvar POINTER_MOUSE = Hammer.POINTER_MOUSE = 'mouse';\n\tvar POINTER_TOUCH = Hammer.POINTER_TOUCH = 'touch';\n\tvar POINTER_PEN = Hammer.POINTER_PEN = 'pen';\n\t\n\t// touch event defines\n\tvar EVENT_START = Hammer.EVENT_START = 'start';\n\tvar EVENT_MOVE = Hammer.EVENT_MOVE = 'move';\n\tvar EVENT_END = Hammer.EVENT_END = 'end';\n\t\n\t\n\t// plugins and gestures namespaces\n\tHammer.plugins = Hammer.plugins || {};\n\tHammer.gestures = Hammer.gestures || {};\n\t\n\t\n\t// if the window events are set...\n\tHammer.READY = false;\n\t\n\t\n\t/**\n\t * setup events to detect gestures on the document\n\t */\n\tfunction setup() {\n\t  if(Hammer.READY) {\n\t    return;\n\t  }\n\t\n\t  // find what eventtypes we add listeners to\n\t  Event.determineEventTypes();\n\t\n\t  // Register all gestures inside Hammer.gestures\n\t  Utils.each(Hammer.gestures, function(gesture){\n\t    Detection.register(gesture);\n\t  });\n\t\n\t  // Add touch events on the document\n\t  Event.onTouch(Hammer.DOCUMENT, EVENT_MOVE, Detection.detect);\n\t  Event.onTouch(Hammer.DOCUMENT, EVENT_END, Detection.detect);\n\t\n\t  // Hammer is ready...!\n\t  Hammer.READY = true;\n\t}\n\t\n\t\n\tvar Utils = Hammer.utils = {\n\t  /**\n\t   * extend method,\n\t   * also used for cloning when dest is an empty object\n\t   * @param   {Object}    dest\n\t   * @param   {Object}    src\n\t   * @parm  {Boolean}  merge    do a merge\n\t   * @returns {Object}    dest\n\t   */\n\t  extend: function extend(dest, src, merge) {\n\t    for(var key in src) {\n\t      if(dest[key] !== undefined && merge) {\n\t        continue;\n\t      }\n\t      dest[key] = src[key];\n\t    }\n\t    return dest;\n\t  },\n\t\n\t\n\t  /**\n\t   * for each\n\t   * @param obj\n\t   * @param iterator\n\t   */\n\t  each: function each(obj, iterator, context) {\n\t    var i, o;\n\t    // native forEach on arrays\n\t    if ('forEach' in obj) {\n\t      obj.forEach(iterator, context);\n\t    }\n\t    // arrays\n\t    else if(obj.length !== undefined) {\n\t      for(i=-1; (o=obj[++i]);) {\n\t        if (iterator.call(context, o, i, obj) === false) {\n\t          return;\n\t        }\n\t      }\n\t    }\n\t    // objects\n\t    else {\n\t      for(i in obj) {\n\t        if(obj.hasOwnProperty(i) &&\n\t            iterator.call(context, obj[i], i, obj) === false) {\n\t          return;\n\t        }\n\t      }\n\t    }\n\t  },\n\t\n\t\n\t  /**\n\t   * find if a string contains the needle\n\t   * @param   {String}  src\n\t   * @param   {String}  needle\n\t   * @returns {Boolean} found\n\t   */\n\t  inStr: function inStr(src, needle) {\n\t    return src.indexOf(needle) > -1;\n\t  },\n\t\n\t\n\t  /**\n\t   * find if a node is in the given parent\n\t   * used for event delegation tricks\n\t   * @param   {HTMLElement}   node\n\t   * @param   {HTMLElement}   parent\n\t   * @returns {boolean}       has_parent\n\t   */\n\t  hasParent: function hasParent(node, parent) {\n\t    while(node) {\n\t      if(node == parent) {\n\t        return true;\n\t      }\n\t      node = node.parentNode;\n\t    }\n\t    return false;\n\t  },\n\t\n\t\n\t  /**\n\t   * get the center of all the touches\n\t   * @param   {Array}     touches\n\t   * @returns {Object}    center pageXY clientXY\n\t   */\n\t  getCenter: function getCenter(touches) {\n\t    var pageX = []\n\t      , pageY = []\n\t      , clientX = []\n\t      , clientY = []\n\t      , min = Math.min\n\t      , max = Math.max;\n\t\n\t    // no need to loop when only one touch\n\t    if(touches.length === 1) {\n\t      return {\n\t        pageX: touches[0].pageX,\n\t        pageY: touches[0].pageY,\n\t        clientX: touches[0].clientX,\n\t        clientY: touches[0].clientY\n\t      };\n\t    }\n\t\n\t    Utils.each(touches, function(touch) {\n\t      pageX.push(touch.pageX);\n\t      pageY.push(touch.pageY);\n\t      clientX.push(touch.clientX);\n\t      clientY.push(touch.clientY);\n\t    });\n\t\n\t    return {\n\t      pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,\n\t      pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,\n\t      clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,\n\t      clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2\n\t    };\n\t  },\n\t\n\t\n\t  /**\n\t   * calculate the velocity between two points\n\t   * @param   {Number}    delta_time\n\t   * @param   {Number}    delta_x\n\t   * @param   {Number}    delta_y\n\t   * @returns {Object}    velocity\n\t   */\n\t  getVelocity: function getVelocity(delta_time, delta_x, delta_y) {\n\t    return {\n\t      x: Math.abs(delta_x / delta_time) || 0,\n\t      y: Math.abs(delta_y / delta_time) || 0\n\t    };\n\t  },\n\t\n\t\n\t  /**\n\t   * calculate the angle between two coordinates\n\t   * @param   {Touch}     touch1\n\t   * @param   {Touch}     touch2\n\t   * @returns {Number}    angle\n\t   */\n\t  getAngle: function getAngle(touch1, touch2) {\n\t    var x = touch2.clientX - touch1.clientX\n\t      , y = touch2.clientY - touch1.clientY;\n\t    return Math.atan2(y, x) * 180 / Math.PI;\n\t  },\n\t\n\t\n\t  /**\n\t   * angle to direction define\n\t   * @param   {Touch}     touch1\n\t   * @param   {Touch}     touch2\n\t   * @returns {String}    direction constant, like DIRECTION_LEFT\n\t   */\n\t  getDirection: function getDirection(touch1, touch2) {\n\t    var x = Math.abs(touch1.clientX - touch2.clientX)\n\t      , y = Math.abs(touch1.clientY - touch2.clientY);\n\t    if(x >= y) {\n\t      return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n\t    }\n\t    return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n\t  },\n\t\n\t\n\t  /**\n\t   * calculate the distance between two touches\n\t   * @param   {Touch}     touch1\n\t   * @param   {Touch}     touch2\n\t   * @returns {Number}    distance\n\t   */\n\t  getDistance: function getDistance(touch1, touch2) {\n\t    var x = touch2.clientX - touch1.clientX\n\t      , y = touch2.clientY - touch1.clientY;\n\t    return Math.sqrt((x * x) + (y * y));\n\t  },\n\t\n\t\n\t  /**\n\t   * calculate the scale factor between two touchLists (fingers)\n\t   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n\t   * @param   {Array}     start\n\t   * @param   {Array}     end\n\t   * @returns {Number}    scale\n\t   */\n\t  getScale: function getScale(start, end) {\n\t    // need two fingers...\n\t    if(start.length >= 2 && end.length >= 2) {\n\t      return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);\n\t    }\n\t    return 1;\n\t  },\n\t\n\t\n\t  /**\n\t   * calculate the rotation degrees between two touchLists (fingers)\n\t   * @param   {Array}     start\n\t   * @param   {Array}     end\n\t   * @returns {Number}    rotation\n\t   */\n\t  getRotation: function getRotation(start, end) {\n\t    // need two fingers\n\t    if(start.length >= 2 && end.length >= 2) {\n\t      return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);\n\t    }\n\t    return 0;\n\t  },\n\t\n\t\n\t  /**\n\t   * boolean if the direction is vertical\n\t   * @param    {String}    direction\n\t   * @returns  {Boolean}   is_vertical\n\t   */\n\t  isVertical: function isVertical(direction) {\n\t    return direction == DIRECTION_UP || direction == DIRECTION_DOWN;\n\t  },\n\t\n\t\n\t  /**\n\t   * toggle browser default behavior with css props\n\t   * @param   {HtmlElement}   element\n\t   * @param   {Object}        css_props\n\t   * @param   {Boolean}       toggle\n\t   */\n\t  toggleDefaultBehavior: function toggleDefaultBehavior(element, css_props, toggle) {\n\t    if(!css_props || !element || !element.style) {\n\t      return;\n\t    }\n\t\n\t    // with css properties for modern browsers\n\t    Utils.each(['webkit', 'moz', 'Moz', 'ms', 'o', ''], function setStyle(vendor) {\n\t      Utils.each(css_props, function(value, prop) {\n\t          // vender prefix at the property\n\t          if(vendor) {\n\t            prop = vendor + prop.substring(0, 1).toUpperCase() + prop.substring(1);\n\t          }\n\t          // set the style\n\t          if(prop in element.style) {\n\t            element.style[prop] = !toggle && value;\n\t          }\n\t      });\n\t    });\n\t\n\t    var false_fn = function(){ return false; };\n\t\n\t    // also the disable onselectstart\n\t    if(css_props.userSelect == 'none') {\n\t      element.onselectstart = !toggle && false_fn;\n\t    }\n\t    // and disable ondragstart\n\t    if(css_props.userDrag == 'none') {\n\t      element.ondragstart = !toggle && false_fn;\n\t    }\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * create new hammer instance\n\t * all methods should return the instance itself, so it is chainable.\n\t * @param   {HTMLElement}       element\n\t * @param   {Object}            [options={}]\n\t * @returns {Hammer.Instance}\n\t * @constructor\n\t */\n\tHammer.Instance = function(element, options) {\n\t  var self = this;\n\t\n\t  // setup HammerJS window events and register all gestures\n\t  // this also sets up the default options\n\t  setup();\n\t\n\t  this.element = element;\n\t\n\t  // start/stop detection option\n\t  this.enabled = true;\n\t\n\t  // merge options\n\t  this.options = Utils.extend(\n\t    Utils.extend({}, Hammer.defaults),\n\t    options || {});\n\t\n\t  // add some css to the element to prevent the browser from doing its native behavoir\n\t  if(this.options.stop_browser_behavior) {\n\t    Utils.toggleDefaultBehavior(this.element, this.options.stop_browser_behavior, false);\n\t  }\n\t\n\t  // start detection on touchstart\n\t  this.eventStartHandler = Event.onTouch(element, EVENT_START, function(ev) {\n\t    if(self.enabled) {\n\t      Detection.startDetect(self, ev);\n\t    }\n\t  });\n\t\n\t  // keep a list of user event handlers which needs to be removed when calling 'dispose'\n\t  this.eventHandlers = [];\n\t\n\t  // return instance\n\t  return this;\n\t};\n\t\n\t\n\tHammer.Instance.prototype = {\n\t  /**\n\t   * bind events to the instance\n\t   * @param   {String}      gesture\n\t   * @param   {Function}    handler\n\t   * @returns {Hammer.Instance}\n\t   */\n\t  on: function onEvent(gesture, handler) {\n\t    var gestures = gesture.split(' ');\n\t    Utils.each(gestures, function(gesture) {\n\t      this.element.addEventListener(gesture, handler, false);\n\t      this.eventHandlers.push({ gesture: gesture, handler: handler });\n\t    }, this);\n\t    return this;\n\t  },\n\t\n\t\n\t  /**\n\t   * unbind events to the instance\n\t   * @param   {String}      gesture\n\t   * @param   {Function}    handler\n\t   * @returns {Hammer.Instance}\n\t   */\n\t  off: function offEvent(gesture, handler) {\n\t    var gestures = gesture.split(' ')\n\t      , i, eh;\n\t    Utils.each(gestures, function(gesture) {\n\t      this.element.removeEventListener(gesture, handler, false);\n\t\n\t      // remove the event handler from the internal list\n\t      for(i=-1; (eh=this.eventHandlers[++i]);) {\n\t        if(eh.gesture === gesture && eh.handler === handler) {\n\t          this.eventHandlers.splice(i, 1);\n\t        }\n\t      }\n\t    }, this);\n\t    return this;\n\t  },\n\t\n\t\n\t  /**\n\t   * trigger gesture event\n\t   * @param   {String}      gesture\n\t   * @param   {Object}      [eventData]\n\t   * @returns {Hammer.Instance}\n\t   */\n\t  trigger: function triggerEvent(gesture, eventData) {\n\t    // optional\n\t    if(!eventData) {\n\t      eventData = {};\n\t    }\n\t\n\t    // create DOM event\n\t    var event = Hammer.DOCUMENT.createEvent('Event');\n\t    event.initEvent(gesture, true, true);\n\t    event.gesture = eventData;\n\t\n\t    // trigger on the target if it is in the instance element,\n\t    // this is for event delegation tricks\n\t    var element = this.element;\n\t    if(Utils.hasParent(eventData.target, element)) {\n\t      element = eventData.target;\n\t    }\n\t\n\t    element.dispatchEvent(event);\n\t    return this;\n\t  },\n\t\n\t\n\t  /**\n\t   * enable of disable hammer.js detection\n\t   * @param   {Boolean}   state\n\t   * @returns {Hammer.Instance}\n\t   */\n\t  enable: function enable(state) {\n\t    this.enabled = state;\n\t    return this;\n\t  },\n\t\n\t\n\t  /**\n\t   * dispose this hammer instance\n\t   * @returns {Hammer.Instance}\n\t   */\n\t  dispose: function dispose() {\n\t    var i, eh;\n\t\n\t    // undo all changes made by stop_browser_behavior\n\t    if(this.options.stop_browser_behavior) {\n\t      Utils.toggleDefaultBehavior(this.element, this.options.stop_browser_behavior, true);\n\t    }\n\t\n\t    // unbind all custom event handlers\n\t    for(i=-1; (eh=this.eventHandlers[++i]);) {\n\t      this.element.removeEventListener(eh.gesture, eh.handler, false);\n\t    }\n\t    this.eventHandlers = [];\n\t\n\t    // unbind the start event listener\n\t    Event.unbindDom(this.element, Hammer.EVENT_TYPES[EVENT_START], this.eventStartHandler);\n\t\n\t    return null;\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * this holds the last move event,\n\t * used to fix empty touchend issue\n\t * see the onTouch event for an explanation\n\t * @type {Object}\n\t */\n\tvar last_move_event = null;\n\t\n\t/**\n\t * when the mouse is hold down, this is true\n\t * @type {Boolean}\n\t */\n\tvar should_detect = false;\n\t\n\t/**\n\t * when touch events have been fired, this is true\n\t * @type {Boolean}\n\t */\n\tvar touch_triggered = false;\n\t\n\t\n\tvar Event = Hammer.event = {\n\t  /**\n\t   * simple addEventListener\n\t   * @param   {HTMLElement}   element\n\t   * @param   {String}        type\n\t   * @param   {Function}      handler\n\t   */\n\t  bindDom: function(element, type, handler) {\n\t    var types = type.split(' ');\n\t    Utils.each(types, function(type){\n\t      element.addEventListener(type, handler, false);\n\t    });\n\t  },\n\t\n\t\n\t  /**\n\t   * simple removeEventListener\n\t   * @param   {HTMLElement}   element\n\t   * @param   {String}        type\n\t   * @param   {Function}      handler\n\t   */\n\t  unbindDom: function(element, type, handler) {\n\t    var types = type.split(' ');\n\t    Utils.each(types, function(type){\n\t      element.removeEventListener(type, handler, false);\n\t    });\n\t  },\n\t\n\t\n\t  /**\n\t   * touch events with mouse fallback\n\t   * @param   {HTMLElement}   element\n\t   * @param   {String}        eventType        like EVENT_MOVE\n\t   * @param   {Function}      handler\n\t   */\n\t  onTouch: function onTouch(element, eventType, handler) {\n\t    var self = this;\n\t\n\t\n\t    var bindDomOnTouch = function bindDomOnTouch(ev) {\n\t      var srcEventType = ev.type.toLowerCase();\n\t\n\t      // onmouseup, but when touchend has been fired we do nothing.\n\t      // this is for touchdevices which also fire a mouseup on touchend\n\t      if(Utils.inStr(srcEventType, 'mouse') && touch_triggered) {\n\t        return;\n\t      }\n\t\n\t      // mousebutton must be down or a touch event\n\t      else if(Utils.inStr(srcEventType, 'touch') ||   // touch events are always on screen\n\t        Utils.inStr(srcEventType, 'pointerdown') || // pointerevents touch\n\t        (Utils.inStr(srcEventType, 'mouse') && ev.which === 1)   // mouse is pressed\n\t        ) {\n\t        should_detect = true;\n\t      }\n\t\n\t      // mouse isn't pressed\n\t      else if(Utils.inStr(srcEventType, 'mouse') && !ev.which) {\n\t        should_detect = false;\n\t      }\n\t\n\t\n\t      // we are in a touch event, set the touch triggered bool to true,\n\t      // this for the conflicts that may occur on ios and android\n\t      if(Utils.inStr(srcEventType, 'touch') || Utils.inStr(srcEventType, 'pointer')) {\n\t        touch_triggered = true;\n\t      }\n\t\n\t      // count the total touches on the screen\n\t      var count_touches = 0;\n\t\n\t      // when touch has been triggered in this detection session\n\t      // and we are now handling a mouse event, we stop that to prevent conflicts\n\t      if(should_detect) {\n\t        // update pointerevent\n\t        if(Hammer.HAS_POINTEREVENTS && eventType != EVENT_END) {\n\t          count_touches = PointerEvent.updatePointer(eventType, ev);\n\t        }\n\t        // touch\n\t        else if(Utils.inStr(srcEventType, 'touch')) {\n\t          count_touches = ev.touches.length;\n\t        }\n\t        // mouse\n\t        else if(!touch_triggered) {\n\t          count_touches = Utils.inStr(srcEventType, 'up') ? 0 : 1;\n\t        }\n\t\n\t\n\t        // if we are in a end event, but when we remove one touch and\n\t        // we still have enough, set eventType to move\n\t        if(count_touches > 0 && eventType == EVENT_END) {\n\t          eventType = EVENT_MOVE;\n\t        }\n\t        // no touches, force the end event\n\t        else if(!count_touches) {\n\t          eventType = EVENT_END;\n\t        }\n\t\n\t        // store the last move event\n\t        if(count_touches || last_move_event === null) {\n\t          last_move_event = ev;\n\t        }\n\t\n\t\n\t        // trigger the handler\n\t        handler.call(Detection, self.collectEventData(element, eventType,\n\t                                  self.getTouchList(last_move_event, eventType),\n\t                                  ev) );\n\t\n\t        // remove pointerevent from list\n\t        if(Hammer.HAS_POINTEREVENTS && eventType == EVENT_END) {\n\t          count_touches = PointerEvent.updatePointer(eventType, ev);\n\t        }\n\t      }\n\t\n\t      // on the end we reset everything\n\t      if(!count_touches) {\n\t        last_move_event = null;\n\t        should_detect = false;\n\t        touch_triggered = false;\n\t        PointerEvent.reset();\n\t      }\n\t    };\n\t\n\t    this.bindDom(element, Hammer.EVENT_TYPES[eventType], bindDomOnTouch);\n\t\n\t    // return the bound function to be able to unbind it later\n\t    return bindDomOnTouch;\n\t  },\n\t\n\t\n\t  /**\n\t   * we have different events for each device/browser\n\t   * determine what we need and set them in the Hammer.EVENT_TYPES constant\n\t   */\n\t  determineEventTypes: function determineEventTypes() {\n\t    // determine the eventtype we want to set\n\t    var types;\n\t\n\t    // pointerEvents magic\n\t    if(Hammer.HAS_POINTEREVENTS) {\n\t      types = PointerEvent.getEvents();\n\t    }\n\t    // on Android, iOS, blackberry, windows mobile we dont want any mouseevents\n\t    else if(Hammer.NO_MOUSEEVENTS) {\n\t      types = [\n\t        'touchstart',\n\t        'touchmove',\n\t        'touchend touchcancel'];\n\t    }\n\t    // for non pointer events browsers and mixed browsers,\n\t    // like chrome on windows8 touch laptop\n\t    else {\n\t      types = [\n\t        'touchstart mousedown',\n\t        'touchmove mousemove',\n\t        'touchend touchcancel mouseup'];\n\t    }\n\t\n\t    Hammer.EVENT_TYPES[EVENT_START] = types[0];\n\t    Hammer.EVENT_TYPES[EVENT_MOVE] = types[1];\n\t    Hammer.EVENT_TYPES[EVENT_END] = types[2];\n\t  },\n\t\n\t\n\t  /**\n\t   * create touchlist depending on the event\n\t   * @param   {Object}    ev\n\t   * @param   {String}    eventType   used by the fakemultitouch plugin\n\t   */\n\t  getTouchList: function getTouchList(ev/*, eventType*/) {\n\t    // get the fake pointerEvent touchlist\n\t    if(Hammer.HAS_POINTEREVENTS) {\n\t      return PointerEvent.getTouchList();\n\t    }\n\t\n\t    // get the touchlist\n\t    if(ev.touches) {\n\t      return ev.touches;\n\t    }\n\t\n\t    // make fake touchlist from mouse position\n\t    ev.identifier = 1;\n\t    return [ev];\n\t  },\n\t\n\t\n\t  /**\n\t   * collect event data for Hammer js\n\t   * @param   {HTMLElement}   element\n\t   * @param   {String}        eventType        like EVENT_MOVE\n\t   * @param   {Object}        eventData\n\t   */\n\t  collectEventData: function collectEventData(element, eventType, touches, ev) {\n\t    // find out pointerType\n\t    var pointerType = POINTER_TOUCH;\n\t    if(Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {\n\t      pointerType = POINTER_MOUSE;\n\t    }\n\t\n\t    return {\n\t      center     : Utils.getCenter(touches),\n\t      timeStamp  : Date.now(),\n\t      target     : ev.target,\n\t      touches    : touches,\n\t      eventType  : eventType,\n\t      pointerType: pointerType,\n\t      srcEvent   : ev,\n\t\n\t      /**\n\t       * prevent the browser default actions\n\t       * mostly used to disable scrolling of the browser\n\t       */\n\t      preventDefault: function() {\n\t        var srcEvent = this.srcEvent;\n\t        srcEvent.preventManipulation && srcEvent.preventManipulation();\n\t        srcEvent.preventDefault && srcEvent.preventDefault();\n\t      },\n\t\n\t      /**\n\t       * stop bubbling the event up to its parents\n\t       */\n\t      stopPropagation: function() {\n\t        this.srcEvent.stopPropagation();\n\t      },\n\t\n\t      /**\n\t       * immediately stop gesture detection\n\t       * might be useful after a swipe was detected\n\t       * @return {*}\n\t       */\n\t      stopDetect: function() {\n\t        return Detection.stopDetect();\n\t      }\n\t    };\n\t  }\n\t};\n\t\n\tvar PointerEvent = Hammer.PointerEvent = {\n\t  /**\n\t   * holds all pointers\n\t   * @type {Object}\n\t   */\n\t  pointers: {},\n\t\n\t  /**\n\t   * get a list of pointers\n\t   * @returns {Array}     touchlist\n\t   */\n\t  getTouchList: function getTouchList() {\n\t    var touchlist = [];\n\t    // we can use forEach since pointerEvents only is in IE10\n\t    Utils.each(this.pointers, function(pointer){\n\t      touchlist.push(pointer);\n\t    });\n\t\n\t    return touchlist;\n\t  },\n\t\n\t  /**\n\t   * update the position of a pointer\n\t   * @param   {String}   type             EVENT_END\n\t   * @param   {Object}   pointerEvent\n\t   */\n\t  updatePointer: function updatePointer(type, pointerEvent) {\n\t    if(type == EVENT_END) {\n\t      delete this.pointers[pointerEvent.pointerId];\n\t    }\n\t    else {\n\t      pointerEvent.identifier = pointerEvent.pointerId;\n\t      this.pointers[pointerEvent.pointerId] = pointerEvent;\n\t    }\n\t\n\t    // it's save to use Object.keys, since pointerEvents are only in newer browsers\n\t    return Object.keys(this.pointers).length;\n\t  },\n\t\n\t  /**\n\t   * check if ev matches pointertype\n\t   * @param   {String}        pointerType     POINTER_MOUSE\n\t   * @param   {PointerEvent}  ev\n\t   */\n\t  matchType: function matchType(pointerType, ev) {\n\t    if(!ev.pointerType) {\n\t      return false;\n\t    }\n\t\n\t    var pt = ev.pointerType\n\t      , types = {};\n\t\n\t    types[POINTER_MOUSE] = (pt === POINTER_MOUSE);\n\t    types[POINTER_TOUCH] = (pt === POINTER_TOUCH);\n\t    types[POINTER_PEN] = (pt === POINTER_PEN);\n\t    return types[pointerType];\n\t  },\n\t\n\t\n\t  /**\n\t   * get events\n\t   */\n\t  getEvents: function getEvents() {\n\t    return [\n\t      'pointerdown MSPointerDown',\n\t      'pointermove MSPointerMove',\n\t      'pointerup pointercancel MSPointerUp MSPointerCancel'\n\t    ];\n\t  },\n\t\n\t  /**\n\t   * reset the list\n\t   */\n\t  reset: function resetList() {\n\t    this.pointers = {};\n\t  }\n\t};\n\t\n\t\n\tvar Detection = Hammer.detection = {\n\t  // contains all registred Hammer.gestures in the correct order\n\t  gestures: [],\n\t\n\t  // data of the current Hammer.gesture detection session\n\t  current : null,\n\t\n\t  // the previous Hammer.gesture session data\n\t  // is a full clone of the previous gesture.current object\n\t  previous: null,\n\t\n\t  // when this becomes true, no gestures are fired\n\t  stopped : false,\n\t\n\t\n\t  /**\n\t   * start Hammer.gesture detection\n\t   * @param   {Hammer.Instance}   inst\n\t   * @param   {Object}            eventData\n\t   */\n\t  startDetect: function startDetect(inst, eventData) {\n\t    // already busy with a Hammer.gesture detection on an element\n\t    if(this.current) {\n\t      return;\n\t    }\n\t\n\t    this.stopped = false;\n\t\n\t    // holds current session\n\t    this.current = {\n\t      inst              : inst, // reference to HammerInstance we're working for\n\t      startEvent        : Utils.extend({}, eventData), // start eventData for distances, timing etc\n\t      lastEvent         : false, // last eventData\n\t      lastVelocityEvent : false, // last eventData for velocity.\n\t      velocity          : false, // current velocity\n\t      name              : '' // current gesture we're in/detected, can be 'tap', 'hold' etc\n\t    };\n\t\n\t    this.detect(eventData);\n\t  },\n\t\n\t\n\t  /**\n\t   * Hammer.gesture detection\n\t   * @param   {Object}    eventData\n\t   */\n\t  detect: function detect(eventData) {\n\t    if(!this.current || this.stopped) {\n\t      return;\n\t    }\n\t\n\t    // extend event data with calculations about scale, distance etc\n\t    eventData = this.extendEventData(eventData);\n\t\n\t    // hammer instance and instance options\n\t    var inst = this.current.inst,\n\t        inst_options = inst.options;\n\t\n\t    // call Hammer.gesture handlers\n\t    Utils.each(this.gestures, function triggerGesture(gesture) {\n\t      // only when the instance options have enabled this gesture\n\t      if(!this.stopped && inst_options[gesture.name] !== false && inst.enabled !== false ) {\n\t        // if a handler returns false, we stop with the detection\n\t        if(gesture.handler.call(gesture, eventData, inst) === false) {\n\t          this.stopDetect();\n\t          return false;\n\t        }\n\t      }\n\t    }, this);\n\t\n\t    // store as previous event event\n\t    if(this.current) {\n\t      this.current.lastEvent = eventData;\n\t    }\n\t\n\t    // end event, but not the last touch, so dont stop\n\t    if(eventData.eventType == EVENT_END && !eventData.touches.length - 1) {\n\t      this.stopDetect();\n\t    }\n\t\n\t    return eventData;\n\t  },\n\t\n\t\n\t  /**\n\t   * clear the Hammer.gesture vars\n\t   * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected\n\t   * to stop other Hammer.gestures from being fired\n\t   */\n\t  stopDetect: function stopDetect() {\n\t    // clone current data to the store as the previous gesture\n\t    // used for the double tap gesture, since this is an other gesture detect session\n\t    this.previous = Utils.extend({}, this.current);\n\t\n\t    // reset the current\n\t    this.current = null;\n\t\n\t    // stopped!\n\t    this.stopped = true;\n\t  },\n\t\n\t\n\t  /**\n\t   * calculate velocity\n\t   * @param   {Object}  ev\n\t   * @param   {Number}  delta_time\n\t   * @param   {Number}  delta_x\n\t   * @param   {Number}  delta_y\n\t   */\n\t  getVelocityData: function getVelocityData(ev, delta_time, delta_x, delta_y) {\n\t    var cur = this.current\n\t      , velocityEv = cur.lastVelocityEvent\n\t      , velocity = cur.velocity;\n\t\n\t    // calculate velocity every x ms\n\t    if (velocityEv && ev.timeStamp - velocityEv.timeStamp > Hammer.UPDATE_VELOCITY_INTERVAL) {\n\t      velocity = Utils.getVelocity(ev.timeStamp - velocityEv.timeStamp,\n\t                                   ev.center.clientX - velocityEv.center.clientX,\n\t                                  ev.center.clientY - velocityEv.center.clientY);\n\t      cur.lastVelocityEvent = ev;\n\t    }\n\t    else if(!cur.velocity) {\n\t      velocity = Utils.getVelocity(delta_time, delta_x, delta_y);\n\t      cur.lastVelocityEvent = ev;\n\t    }\n\t\n\t    cur.velocity = velocity;\n\t\n\t    ev.velocityX = velocity.x;\n\t    ev.velocityY = velocity.y;\n\t  },\n\t\n\t\n\t  /**\n\t   * calculate interim angle and direction\n\t   * @param   {Object}  ev\n\t   */\n\t  getInterimData: function getInterimData(ev) {\n\t    var lastEvent = this.current.lastEvent\n\t      , angle\n\t      , direction;\n\t\n\t    // end events (e.g. dragend) don't have useful values for interimDirection & interimAngle\n\t    // because the previous event has exactly the same coordinates\n\t    // so for end events, take the previous values of interimDirection & interimAngle\n\t    // instead of recalculating them and getting a spurious '0'\n\t    if(ev.eventType == EVENT_END) {\n\t      angle = lastEvent && lastEvent.interimAngle;\n\t      direction = lastEvent && lastEvent.interimDirection;\n\t    }\n\t    else {\n\t      angle = lastEvent && Utils.getAngle(lastEvent.center, ev.center);\n\t      direction = lastEvent && Utils.getDirection(lastEvent.center, ev.center);\n\t    }\n\t\n\t    ev.interimAngle = angle;\n\t    ev.interimDirection = direction;\n\t  },\n\t\n\t\n\t  /**\n\t   * extend eventData for Hammer.gestures\n\t   * @param   {Object}   evData\n\t   * @returns {Object}   evData\n\t   */\n\t  extendEventData: function extendEventData(ev) {\n\t    var cur = this.current\n\t      , startEv = cur.startEvent;\n\t\n\t    // if the touches change, set the new touches over the startEvent touches\n\t    // this because touchevents don't have all the touches on touchstart, or the\n\t    // user must place his fingers at the EXACT same time on the screen, which is not realistic\n\t    // but, sometimes it happens that both fingers are touching at the EXACT same time\n\t    if(ev.touches.length != startEv.touches.length || ev.touches === startEv.touches) {\n\t      // extend 1 level deep to get the touchlist with the touch objects\n\t      startEv.touches = [];\n\t      Utils.each(ev.touches, function(touch) {\n\t        startEv.touches.push(Utils.extend({}, touch));\n\t      });\n\t    }\n\t\n\t    var delta_time = ev.timeStamp - startEv.timeStamp\n\t      , delta_x = ev.center.clientX - startEv.center.clientX\n\t      , delta_y = ev.center.clientY - startEv.center.clientY;\n\t\n\t    this.getVelocityData(ev, delta_time, delta_x, delta_y);\n\t    this.getInterimData(ev);\n\t\n\t    Utils.extend(ev, {\n\t      startEvent: startEv,\n\t\n\t      deltaTime : delta_time,\n\t      deltaX    : delta_x,\n\t      deltaY    : delta_y,\n\t\n\t      distance  : Utils.getDistance(startEv.center, ev.center),\n\t      angle     : Utils.getAngle(startEv.center, ev.center),\n\t      direction : Utils.getDirection(startEv.center, ev.center),\n\t\n\t      scale     : Utils.getScale(startEv.touches, ev.touches),\n\t      rotation  : Utils.getRotation(startEv.touches, ev.touches)\n\t    });\n\t\n\t    return ev;\n\t  },\n\t\n\t\n\t  /**\n\t   * register new gesture\n\t   * @param   {Object}    gesture object, see gestures.js for documentation\n\t   * @returns {Array}     gestures\n\t   */\n\t  register: function register(gesture) {\n\t    // add an enable gesture options if there is no given\n\t    var options = gesture.defaults || {};\n\t    if(options[gesture.name] === undefined) {\n\t      options[gesture.name] = true;\n\t    }\n\t\n\t    // extend Hammer default options with the Hammer.gesture options\n\t    Utils.extend(Hammer.defaults, options, true);\n\t\n\t    // set its index\n\t    gesture.index = gesture.index || 1000;\n\t\n\t    // add Hammer.gesture to the list\n\t    this.gestures.push(gesture);\n\t\n\t    // sort the list by index\n\t    this.gestures.sort(function(a, b) {\n\t      if(a.index < b.index) { return -1; }\n\t      if(a.index > b.index) { return 1; }\n\t      return 0;\n\t    });\n\t\n\t    return this.gestures;\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Drag\n\t * Move with x fingers (default 1) around on the page. Blocking the scrolling when\n\t * moving left and right is a good practice. When all the drag events are blocking\n\t * you disable scrolling on that area.\n\t * @events  drag, drapleft, dragright, dragup, dragdown\n\t */\n\tHammer.gestures.Drag = {\n\t  name     : 'drag',\n\t  index    : 50,\n\t  defaults : {\n\t    drag_min_distance            : 10,\n\t\n\t    // Set correct_for_drag_min_distance to true to make the starting point of the drag\n\t    // be calculated from where the drag was triggered, not from where the touch started.\n\t    // Useful to avoid a jerk-starting drag, which can make fine-adjustments\n\t    // through dragging difficult, and be visually unappealing.\n\t    correct_for_drag_min_distance: true,\n\t\n\t    // set 0 for unlimited, but this can conflict with transform\n\t    drag_max_touches             : 1,\n\t\n\t    // prevent default browser behavior when dragging occurs\n\t    // be careful with it, it makes the element a blocking element\n\t    // when you are using the drag gesture, it is a good practice to set this true\n\t    drag_block_horizontal        : false,\n\t    drag_block_vertical          : false,\n\t\n\t    // drag_lock_to_axis keeps the drag gesture on the axis that it started on,\n\t    // It disallows vertical directions if the initial direction was horizontal, and vice versa.\n\t    drag_lock_to_axis            : false,\n\t\n\t    // drag lock only kicks in when distance > drag_lock_min_distance\n\t    // This way, locking occurs only when the distance has become large enough to reliably determine the direction\n\t    drag_lock_min_distance       : 25\n\t  },\n\t\n\t  triggered: false,\n\t  handler  : function dragGesture(ev, inst) {\n\t    var cur = Detection.current;\n\t\n\t    // current gesture isnt drag, but dragged is true\n\t    // this means an other gesture is busy. now call dragend\n\t    if(cur.name != this.name && this.triggered) {\n\t      inst.trigger(this.name + 'end', ev);\n\t      this.triggered = false;\n\t      return;\n\t    }\n\t\n\t    // max touches\n\t    if(inst.options.drag_max_touches > 0 &&\n\t      ev.touches.length > inst.options.drag_max_touches) {\n\t      return;\n\t    }\n\t\n\t    switch(ev.eventType) {\n\t      case EVENT_START:\n\t        this.triggered = false;\n\t        break;\n\t\n\t      case EVENT_MOVE:\n\t        // when the distance we moved is too small we skip this gesture\n\t        // or we can be already in dragging\n\t        if(ev.distance < inst.options.drag_min_distance &&\n\t          cur.name != this.name) {\n\t          return;\n\t        }\n\t\n\t        var startCenter = cur.startEvent.center;\n\t\n\t        // we are dragging!\n\t        if(cur.name != this.name) {\n\t          cur.name = this.name;\n\t          if(inst.options.correct_for_drag_min_distance && ev.distance > 0) {\n\t            // When a drag is triggered, set the event center to drag_min_distance pixels from the original event center.\n\t            // Without this correction, the dragged distance would jumpstart at drag_min_distance pixels instead of at 0.\n\t            // It might be useful to save the original start point somewhere\n\t            var factor = Math.abs(inst.options.drag_min_distance / ev.distance);\n\t            startCenter.pageX += ev.deltaX * factor;\n\t            startCenter.pageY += ev.deltaY * factor;\n\t            startCenter.clientX += ev.deltaX * factor;\n\t            startCenter.clientY += ev.deltaY * factor;\n\t\n\t            // recalculate event data using new start point\n\t            ev = Detection.extendEventData(ev);\n\t          }\n\t        }\n\t\n\t        // lock drag to axis?\n\t        if(cur.lastEvent.drag_locked_to_axis ||\n\t            ( inst.options.drag_lock_to_axis &&\n\t              inst.options.drag_lock_min_distance <= ev.distance\n\t            )) {\n\t          ev.drag_locked_to_axis = true;\n\t        }\n\t        var last_direction = cur.lastEvent.direction;\n\t        if(ev.drag_locked_to_axis && last_direction !== ev.direction) {\n\t          // keep direction on the axis that the drag gesture started on\n\t          if(Utils.isVertical(last_direction)) {\n\t            ev.direction = (ev.deltaY < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n\t          }\n\t          else {\n\t            ev.direction = (ev.deltaX < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n\t          }\n\t        }\n\t\n\t        // first time, trigger dragstart event\n\t        if(!this.triggered) {\n\t          inst.trigger(this.name + 'start', ev);\n\t          this.triggered = true;\n\t        }\n\t\n\t        // trigger events\n\t        inst.trigger(this.name, ev);\n\t        inst.trigger(this.name + ev.direction, ev);\n\t\n\t        var is_vertical = Utils.isVertical(ev.direction);\n\t\n\t        // block the browser events\n\t        if((inst.options.drag_block_vertical && is_vertical) ||\n\t          (inst.options.drag_block_horizontal && !is_vertical)) {\n\t          ev.preventDefault();\n\t        }\n\t        break;\n\t\n\t      case EVENT_END:\n\t        // trigger dragend\n\t        if(this.triggered) {\n\t          inst.trigger(this.name + 'end', ev);\n\t        }\n\t\n\t        this.triggered = false;\n\t        break;\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Hold\n\t * Touch stays at the same place for x time\n\t * @events  hold\n\t */\n\tHammer.gestures.Hold = {\n\t  name    : 'hold',\n\t  index   : 10,\n\t  defaults: {\n\t    hold_timeout  : 500,\n\t    hold_threshold: 2\n\t  },\n\t  timer   : null,\n\t\n\t  handler : function holdGesture(ev, inst) {\n\t    switch(ev.eventType) {\n\t      case EVENT_START:\n\t        // clear any running timers\n\t        clearTimeout(this.timer);\n\t\n\t        // set the gesture so we can check in the timeout if it still is\n\t        Detection.current.name = this.name;\n\t\n\t        // set timer and if after the timeout it still is hold,\n\t        // we trigger the hold event\n\t        this.timer = setTimeout(function() {\n\t          if(Detection.current.name == 'hold') {\n\t            inst.trigger('hold', ev);\n\t          }\n\t        }, inst.options.hold_timeout);\n\t        break;\n\t\n\t      // when you move or end we clear the timer\n\t      case EVENT_MOVE:\n\t        if(ev.distance > inst.options.hold_threshold) {\n\t          clearTimeout(this.timer);\n\t        }\n\t        break;\n\t\n\t      case EVENT_END:\n\t        clearTimeout(this.timer);\n\t        break;\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Release\n\t * Called as last, tells the user has released the screen\n\t * @events  release\n\t */\n\tHammer.gestures.Release = {\n\t  name   : 'release',\n\t  index  : Infinity,\n\t  handler: function releaseGesture(ev, inst) {\n\t    if(ev.eventType == EVENT_END) {\n\t      inst.trigger(this.name, ev);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Swipe\n\t * triggers swipe events when the end velocity is above the threshold\n\t * for best usage, set prevent_default (on the drag gesture) to true\n\t * @events  swipe, swipeleft, swiperight, swipeup, swipedown\n\t */\n\tHammer.gestures.Swipe = {\n\t  name    : 'swipe',\n\t  index   : 40,\n\t  defaults: {\n\t    swipe_min_touches: 1,\n\t    swipe_max_touches: 1,\n\t    swipe_velocity   : 0.7\n\t  },\n\t  handler : function swipeGesture(ev, inst) {\n\t    if(ev.eventType == EVENT_END) {\n\t      // max touches\n\t      if(ev.touches.length < inst.options.swipe_min_touches ||\n\t        ev.touches.length > inst.options.swipe_max_touches) {\n\t        return;\n\t      }\n\t\n\t      // when the distance we moved is too small we skip this gesture\n\t      // or we can be already in dragging\n\t      if(ev.velocityX > inst.options.swipe_velocity ||\n\t        ev.velocityY > inst.options.swipe_velocity) {\n\t        // trigger swipe events\n\t        inst.trigger(this.name, ev);\n\t        inst.trigger(this.name + ev.direction, ev);\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Tap/DoubleTap\n\t * Quick touch at a place or double at the same place\n\t * @events  tap, doubletap\n\t */\n\tHammer.gestures.Tap = {\n\t  name    : 'tap',\n\t  index   : 100,\n\t  defaults: {\n\t    tap_max_touchtime : 250,\n\t    tap_max_distance  : 10,\n\t    tap_always        : true,\n\t    doubletap_distance: 20,\n\t    doubletap_interval: 300\n\t  },\n\t\n\t  has_moved: false,\n\t\n\t  handler : function tapGesture(ev, inst) {\n\t    var prev, since_prev, did_doubletap;\n\t\n\t    // reset moved state\n\t    if(ev.eventType == EVENT_START) {\n\t      this.has_moved = false;\n\t    }\n\t\n\t    // Track the distance we've moved. If it's above the max ONCE, remember that (fixes #406).\n\t    else if(ev.eventType == EVENT_MOVE && !this.moved) {\n\t      this.has_moved = (ev.distance > inst.options.tap_max_distance);\n\t    }\n\t\n\t    else if(ev.eventType == EVENT_END &&\n\t        ev.srcEvent.type != 'touchcancel' &&\n\t        ev.deltaTime < inst.options.tap_max_touchtime && !this.has_moved) {\n\t\n\t      // previous gesture, for the double tap since these are two different gesture detections\n\t      prev = Detection.previous;\n\t      since_prev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;\n\t      did_doubletap = false;\n\t\n\t      // check if double tap\n\t      if(prev && prev.name == 'tap' &&\n\t          (since_prev && since_prev < inst.options.doubletap_interval) &&\n\t          ev.distance < inst.options.doubletap_distance) {\n\t        inst.trigger('doubletap', ev);\n\t        did_doubletap = true;\n\t      }\n\t\n\t      // do a single tap\n\t      if(!did_doubletap || inst.options.tap_always) {\n\t        Detection.current.name = 'tap';\n\t        inst.trigger(Detection.current.name, ev);\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Touch\n\t * Called as first, tells the user has touched the screen\n\t * @events  touch\n\t */\n\tHammer.gestures.Touch = {\n\t  name    : 'touch',\n\t  index   : -Infinity,\n\t  defaults: {\n\t    // call preventDefault at touchstart, and makes the element blocking by\n\t    // disabling the scrolling of the page, but it improves gestures like\n\t    // transforming and dragging.\n\t    // be careful with using this, it can be very annoying for users to be stuck\n\t    // on the page\n\t    prevent_default    : false,\n\t\n\t    // disable mouse events, so only touch (or pen!) input triggers events\n\t    prevent_mouseevents: false\n\t  },\n\t  handler : function touchGesture(ev, inst) {\n\t    if(inst.options.prevent_mouseevents &&\n\t        ev.pointerType == POINTER_MOUSE) {\n\t      ev.stopDetect();\n\t      return;\n\t    }\n\t\n\t    if(inst.options.prevent_default) {\n\t      ev.preventDefault();\n\t    }\n\t\n\t    if(ev.eventType == EVENT_START) {\n\t      inst.trigger(this.name, ev);\n\t    }\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Transform\n\t * User want to scale or rotate with 2 fingers\n\t * @events  transform, pinch, pinchin, pinchout, rotate\n\t */\n\tHammer.gestures.Transform = {\n\t  name     : 'transform',\n\t  index    : 45,\n\t  defaults : {\n\t    // factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1\n\t    transform_min_scale      : 0.01,\n\t    // rotation in degrees\n\t    transform_min_rotation   : 1,\n\t    // prevent default browser behavior when two touches are on the screen\n\t    // but it makes the element a blocking element\n\t    // when you are using the transform gesture, it is a good practice to set this true\n\t    transform_always_block   : false,\n\t    // ensures that all touches occurred within the instance element\n\t    transform_within_instance: false\n\t  },\n\t\n\t  triggered: false,\n\t\n\t  handler  : function transformGesture(ev, inst) {\n\t    // current gesture isnt drag, but dragged is true\n\t    // this means an other gesture is busy. now call dragend\n\t    if(Detection.current.name != this.name && this.triggered) {\n\t      inst.trigger(this.name + 'end', ev);\n\t      this.triggered = false;\n\t      return;\n\t    }\n\t\n\t    // at least multitouch\n\t    if(ev.touches.length < 2) {\n\t      return;\n\t    }\n\t\n\t    // prevent default when two fingers are on the screen\n\t    if(inst.options.transform_always_block) {\n\t      ev.preventDefault();\n\t    }\n\t\n\t    // check if all touches occurred within the instance element\n\t    if(inst.options.transform_within_instance) {\n\t      for(var i=-1; ev.touches[++i];) {\n\t        if(!Utils.hasParent(ev.touches[i].target, inst.element)) {\n\t          return;\n\t        }\n\t      }\n\t    }\n\t\n\t    switch(ev.eventType) {\n\t      case EVENT_START:\n\t        this.triggered = false;\n\t        break;\n\t\n\t      case EVENT_MOVE:\n\t        var scale_threshold = Math.abs(1 - ev.scale);\n\t        var rotation_threshold = Math.abs(ev.rotation);\n\t\n\t        // when the distance we moved is too small we skip this gesture\n\t        // or we can be already in dragging\n\t        if(scale_threshold < inst.options.transform_min_scale &&\n\t          rotation_threshold < inst.options.transform_min_rotation) {\n\t          return;\n\t        }\n\t\n\t        // we are transforming!\n\t        Detection.current.name = this.name;\n\t\n\t        // first time, trigger dragstart event\n\t        if(!this.triggered) {\n\t          inst.trigger(this.name + 'start', ev);\n\t          this.triggered = true;\n\t        }\n\t\n\t        inst.trigger(this.name, ev); // basic transform event\n\t\n\t        // trigger rotate event\n\t        if(rotation_threshold > inst.options.transform_min_rotation) {\n\t          inst.trigger('rotate', ev);\n\t        }\n\t\n\t        // trigger pinch event\n\t        if(scale_threshold > inst.options.transform_min_scale) {\n\t          inst.trigger('pinch', ev);\n\t          inst.trigger('pinch' + (ev.scale<1 ? 'in' : 'out'), ev);\n\t        }\n\t        break;\n\t\n\t      case EVENT_END:\n\t        // trigger dragend\n\t        if(this.triggered) {\n\t          inst.trigger(this.name + 'end', ev);\n\t        }\n\t\n\t        this.triggered = false;\n\t        break;\n\t    }\n\t  }\n\t};\n\t\n\t// AMD export\n\tif(true) {\n\t  !(__WEBPACK_AMD_DEFINE_RESULT__ = function(){\n\t    return Hammer;\n\t  }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\t// commonjs export\n\telse if(typeof module == 'object' && module.exports) {\n\t  module.exports = Hammer;\n\t}\n\t// browser export\n\telse {\n\t  window.Hammer = Hammer;\n\t}\n\t\n\t})(window);\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tmodule.exports = function addStyle(cssCode) {\r\n\t\tif(false) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\tvar styleElement = document.createElement(\"style\"),\r\n\t\t\thead = document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\thead.appendChild(styleElement);\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = cssCode;\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(document.createTextNode(cssCode));\r\n\t\t}\r\n\t\tif(false) {\r\n\t\t\treturn function(cssCode) {\r\n\t\t\t\tif(typeof cssCode === \"string\") {\r\n\t\t\t\t\tif (styleElement.styleSheet) {\r\n\t\t\t\t\t\tstyleElement.styleSheet.cssText = cssCode;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstyleElement.childNodes[0].nodeValue = cssCode;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdispose();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\t// For the useable API, provide a function to remove the stylesheet.\r\n\t\t\treturn dispose;\r\n\t\t}\r\n\t\r\n\t\tfunction dispose() {\r\n\t\t\thead.removeChild(styleElement);\r\n\t\t}\r\n\t};\r\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\tvar update = __webpack_require__(11)(\n\t\t__webpack_require__(9)\n\t);\n\t// Hot Module Replacement\n\tif(false) {\n\t\tmodule.hot.accept(\"!!/home/bodil/workspace/pink/node_modules/css-loader/index.js!/home/bodil/workspace/pink/node_modules/less-loader/index.js!/home/bodil/workspace/pink/css/screen.less\", function() {\n\t\t\tupdate(require(\"!!/home/bodil/workspace/pink/node_modules/css-loader/index.js!/home/bodil/workspace/pink/node_modules/less-loader/index.js!/home/bodil/workspace/pink/css/screen.less\"));\n\t\t});\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {(function(global) {\n\t  'use strict';\n\t  if (global.$traceurRuntime) {\n\t    return;\n\t  }\n\t  var $Object = Object;\n\t  var $TypeError = TypeError;\n\t  var $create = $Object.create;\n\t  var $defineProperties = $Object.defineProperties;\n\t  var $defineProperty = $Object.defineProperty;\n\t  var $freeze = $Object.freeze;\n\t  var $getOwnPropertyDescriptor = $Object.getOwnPropertyDescriptor;\n\t  var $getOwnPropertyNames = $Object.getOwnPropertyNames;\n\t  var $getPrototypeOf = $Object.getPrototypeOf;\n\t  var $hasOwnProperty = $Object.prototype.hasOwnProperty;\n\t  var $toString = $Object.prototype.toString;\n\t  function nonEnum(value) {\n\t    return {\n\t      configurable: true,\n\t      enumerable: false,\n\t      value: value,\n\t      writable: true\n\t    };\n\t  }\n\t  var method = nonEnum;\n\t  var counter = 0;\n\t  function newUniqueString() {\n\t    return '__$' + Math.floor(Math.random() * 1e9) + '$' + ++counter + '$__';\n\t  }\n\t  var symbolInternalProperty = newUniqueString();\n\t  var symbolDescriptionProperty = newUniqueString();\n\t  var symbolDataProperty = newUniqueString();\n\t  var symbolValues = $create(null);\n\t  function isSymbol(symbol) {\n\t    return typeof symbol === 'object' && symbol instanceof SymbolValue;\n\t  }\n\t  function typeOf(v) {\n\t    if (isSymbol(v))\n\t      return 'symbol';\n\t    return typeof v;\n\t  }\n\t  function Symbol(description) {\n\t    var value = new SymbolValue(description);\n\t    if (!(this instanceof Symbol))\n\t      return value;\n\t    throw new TypeError('Symbol cannot be new\\'ed');\n\t  }\n\t  $defineProperty(Symbol.prototype, 'constructor', nonEnum(Symbol));\n\t  $defineProperty(Symbol.prototype, 'toString', method(function() {\n\t    var symbolValue = this[symbolDataProperty];\n\t    if (!getOption('symbols'))\n\t      return symbolValue[symbolInternalProperty];\n\t    if (!symbolValue)\n\t      throw TypeError('Conversion from symbol to string');\n\t    var desc = symbolValue[symbolDescriptionProperty];\n\t    if (desc === undefined)\n\t      desc = '';\n\t    return 'Symbol(' + desc + ')';\n\t  }));\n\t  $defineProperty(Symbol.prototype, 'valueOf', method(function() {\n\t    var symbolValue = this[symbolDataProperty];\n\t    if (!symbolValue)\n\t      throw TypeError('Conversion from symbol to string');\n\t    if (!getOption('symbols'))\n\t      return symbolValue[symbolInternalProperty];\n\t    return symbolValue;\n\t  }));\n\t  function SymbolValue(description) {\n\t    var key = newUniqueString();\n\t    $defineProperty(this, symbolDataProperty, {value: this});\n\t    $defineProperty(this, symbolInternalProperty, {value: key});\n\t    $defineProperty(this, symbolDescriptionProperty, {value: description});\n\t    $freeze(this);\n\t    symbolValues[key] = this;\n\t  }\n\t  $defineProperty(SymbolValue.prototype, 'constructor', nonEnum(Symbol));\n\t  $defineProperty(SymbolValue.prototype, 'toString', {\n\t    value: Symbol.prototype.toString,\n\t    enumerable: false\n\t  });\n\t  $defineProperty(SymbolValue.prototype, 'valueOf', {\n\t    value: Symbol.prototype.valueOf,\n\t    enumerable: false\n\t  });\n\t  $freeze(SymbolValue.prototype);\n\t  Symbol.iterator = Symbol();\n\t  function toProperty(name) {\n\t    if (isSymbol(name))\n\t      return name[symbolInternalProperty];\n\t    return name;\n\t  }\n\t  function getOwnPropertyNames(object) {\n\t    var rv = [];\n\t    var names = $getOwnPropertyNames(object);\n\t    for (var i = 0; i < names.length; i++) {\n\t      var name = names[i];\n\t      if (!symbolValues[name])\n\t        rv.push(name);\n\t    }\n\t    return rv;\n\t  }\n\t  function getOwnPropertyDescriptor(object, name) {\n\t    return $getOwnPropertyDescriptor(object, toProperty(name));\n\t  }\n\t  function getOwnPropertySymbols(object) {\n\t    var rv = [];\n\t    var names = $getOwnPropertyNames(object);\n\t    for (var i = 0; i < names.length; i++) {\n\t      var symbol = symbolValues[names[i]];\n\t      if (symbol)\n\t        rv.push(symbol);\n\t    }\n\t    return rv;\n\t  }\n\t  function hasOwnProperty(name) {\n\t    return $hasOwnProperty.call(this, toProperty(name));\n\t  }\n\t  function getOption(name) {\n\t    return global.traceur && global.traceur.options[name];\n\t  }\n\t  function setProperty(object, name, value) {\n\t    var sym,\n\t        desc;\n\t    if (isSymbol(name)) {\n\t      sym = name;\n\t      name = name[symbolInternalProperty];\n\t    }\n\t    object[name] = value;\n\t    if (sym && (desc = $getOwnPropertyDescriptor(object, name)))\n\t      $defineProperty(object, name, {enumerable: false});\n\t    return value;\n\t  }\n\t  function defineProperty(object, name, descriptor) {\n\t    if (isSymbol(name)) {\n\t      if (descriptor.enumerable) {\n\t        descriptor = $create(descriptor, {enumerable: {value: false}});\n\t      }\n\t      name = name[symbolInternalProperty];\n\t    }\n\t    $defineProperty(object, name, descriptor);\n\t    return object;\n\t  }\n\t  function polyfillObject(Object) {\n\t    $defineProperty(Object, 'defineProperty', {value: defineProperty});\n\t    $defineProperty(Object, 'getOwnPropertyNames', {value: getOwnPropertyNames});\n\t    $defineProperty(Object, 'getOwnPropertyDescriptor', {value: getOwnPropertyDescriptor});\n\t    $defineProperty(Object.prototype, 'hasOwnProperty', {value: hasOwnProperty});\n\t    Object.getOwnPropertySymbols = getOwnPropertySymbols;\n\t    function is(left, right) {\n\t      if (left === right)\n\t        return left !== 0 || 1 / left === 1 / right;\n\t      return left !== left && right !== right;\n\t    }\n\t    $defineProperty(Object, 'is', method(is));\n\t    function assign(target, source) {\n\t      var props = $getOwnPropertyNames(source);\n\t      var p,\n\t          length = props.length;\n\t      for (p = 0; p < length; p++) {\n\t        target[props[p]] = source[props[p]];\n\t      }\n\t      return target;\n\t    }\n\t    $defineProperty(Object, 'assign', method(assign));\n\t    function mixin(target, source) {\n\t      var props = $getOwnPropertyNames(source);\n\t      var p,\n\t          descriptor,\n\t          length = props.length;\n\t      for (p = 0; p < length; p++) {\n\t        descriptor = $getOwnPropertyDescriptor(source, props[p]);\n\t        $defineProperty(target, props[p], descriptor);\n\t      }\n\t      return target;\n\t    }\n\t    $defineProperty(Object, 'mixin', method(mixin));\n\t  }\n\t  function exportStar(object) {\n\t    for (var i = 1; i < arguments.length; i++) {\n\t      var names = $getOwnPropertyNames(arguments[i]);\n\t      for (var j = 0; j < names.length; j++) {\n\t        (function(mod, name) {\n\t          $defineProperty(object, name, {\n\t            get: function() {\n\t              return mod[name];\n\t            },\n\t            enumerable: true\n\t          });\n\t        })(arguments[i], names[j]);\n\t      }\n\t    }\n\t    return object;\n\t  }\n\t  function toObject(value) {\n\t    if (value == null)\n\t      throw $TypeError();\n\t    return $Object(value);\n\t  }\n\t  function spread() {\n\t    var rv = [],\n\t        k = 0;\n\t    for (var i = 0; i < arguments.length; i++) {\n\t      var valueToSpread = toObject(arguments[i]);\n\t      for (var j = 0; j < valueToSpread.length; j++) {\n\t        rv[k++] = valueToSpread[j];\n\t      }\n\t    }\n\t    return rv;\n\t  }\n\t  function getPropertyDescriptor(object, name) {\n\t    while (object !== null) {\n\t      var result = $getOwnPropertyDescriptor(object, name);\n\t      if (result)\n\t        return result;\n\t      object = $getPrototypeOf(object);\n\t    }\n\t    return undefined;\n\t  }\n\t  function superDescriptor(homeObject, name) {\n\t    var proto = $getPrototypeOf(homeObject);\n\t    if (!proto)\n\t      throw $TypeError('super is null');\n\t    return getPropertyDescriptor(proto, name);\n\t  }\n\t  function superCall(self, homeObject, name, args) {\n\t    var descriptor = superDescriptor(homeObject, name);\n\t    if (descriptor) {\n\t      if ('value' in descriptor)\n\t        return descriptor.value.apply(self, args);\n\t      if (descriptor.get)\n\t        return descriptor.get.call(self).apply(self, args);\n\t    }\n\t    throw $TypeError(\"super has no method '\" + name + \"'.\");\n\t  }\n\t  function superGet(self, homeObject, name) {\n\t    var descriptor = superDescriptor(homeObject, name);\n\t    if (descriptor) {\n\t      if (descriptor.get)\n\t        return descriptor.get.call(self);\n\t      else if ('value' in descriptor)\n\t        return descriptor.value;\n\t    }\n\t    return undefined;\n\t  }\n\t  function superSet(self, homeObject, name, value) {\n\t    var descriptor = superDescriptor(homeObject, name);\n\t    if (descriptor && descriptor.set) {\n\t      descriptor.set.call(self, value);\n\t      return;\n\t    }\n\t    throw $TypeError(\"super has no setter '\" + name + \"'.\");\n\t  }\n\t  function getDescriptors(object) {\n\t    var descriptors = {},\n\t        name,\n\t        names = $getOwnPropertyNames(object);\n\t    for (var i = 0; i < names.length; i++) {\n\t      var name = names[i];\n\t      descriptors[name] = $getOwnPropertyDescriptor(object, name);\n\t    }\n\t    return descriptors;\n\t  }\n\t  function createClass(ctor, object, staticObject, superClass) {\n\t    $defineProperty(object, 'constructor', {\n\t      value: ctor,\n\t      configurable: true,\n\t      enumerable: false,\n\t      writable: true\n\t    });\n\t    if (arguments.length > 3) {\n\t      if (typeof superClass === 'function')\n\t        ctor.__proto__ = superClass;\n\t      ctor.prototype = $create(getProtoParent(superClass), getDescriptors(object));\n\t    } else {\n\t      ctor.prototype = object;\n\t    }\n\t    $defineProperty(ctor, 'prototype', {\n\t      configurable: false,\n\t      writable: false\n\t    });\n\t    return $defineProperties(ctor, getDescriptors(staticObject));\n\t  }\n\t  function getProtoParent(superClass) {\n\t    if (typeof superClass === 'function') {\n\t      var prototype = superClass.prototype;\n\t      if ($Object(prototype) === prototype || prototype === null)\n\t        return superClass.prototype;\n\t    }\n\t    if (superClass === null)\n\t      return null;\n\t    throw new TypeError();\n\t  }\n\t  function defaultSuperCall(self, homeObject, args) {\n\t    if ($getPrototypeOf(homeObject) !== null)\n\t      superCall(self, homeObject, 'constructor', args);\n\t  }\n\t  var ST_NEWBORN = 0;\n\t  var ST_EXECUTING = 1;\n\t  var ST_SUSPENDED = 2;\n\t  var ST_CLOSED = 3;\n\t  var END_STATE = -3;\n\t  function addIterator(object) {\n\t    return defineProperty(object, Symbol.iterator, nonEnum(function() {\n\t      return this;\n\t    }));\n\t  }\n\t  function GeneratorContext() {\n\t    this.state = 0;\n\t    this.GState = ST_NEWBORN;\n\t    this.storedException = undefined;\n\t    this.finallyFallThrough = undefined;\n\t    this.sent = undefined;\n\t    this.returnValue = undefined;\n\t    this.tryStack_ = [];\n\t  }\n\t  GeneratorContext.prototype = {\n\t    pushTry: function(catchState, finallyState) {\n\t      if (finallyState !== null) {\n\t        var finallyFallThrough = null;\n\t        for (var i = this.tryStack_.length - 1; i >= 0; i--) {\n\t          if (this.tryStack_[i].catch !== undefined) {\n\t            finallyFallThrough = this.tryStack_[i].catch;\n\t            break;\n\t          }\n\t        }\n\t        if (finallyFallThrough === null)\n\t          finallyFallThrough = -3;\n\t        this.tryStack_.push({\n\t          finally: finallyState,\n\t          finallyFallThrough: finallyFallThrough\n\t        });\n\t      }\n\t      if (catchState !== null) {\n\t        this.tryStack_.push({catch: catchState});\n\t      }\n\t    },\n\t    popTry: function() {\n\t      this.tryStack_.pop();\n\t    }\n\t  };\n\t  function getNextOrThrow(ctx, moveNext, action) {\n\t    return function(x) {\n\t      switch (ctx.GState) {\n\t        case ST_EXECUTING:\n\t          throw new Error((\"\\\"\" + action + \"\\\" on executing generator\"));\n\t        case ST_CLOSED:\n\t          throw new Error((\"\\\"\" + action + \"\\\" on closed generator\"));\n\t        case ST_NEWBORN:\n\t          if (action === 'throw') {\n\t            ctx.GState = ST_CLOSED;\n\t            throw x;\n\t          }\n\t          if (x !== undefined)\n\t            throw $TypeError('Sent value to newborn generator');\n\t        case ST_SUSPENDED:\n\t          ctx.GState = ST_EXECUTING;\n\t          ctx.action = action;\n\t          ctx.sent = x;\n\t          var value = moveNext(ctx);\n\t          var done = value === ctx;\n\t          if (done)\n\t            value = ctx.returnValue;\n\t          ctx.GState = done ? ST_CLOSED : ST_SUSPENDED;\n\t          return {\n\t            value: value,\n\t            done: done\n\t          };\n\t      }\n\t    };\n\t  }\n\t  function generatorWrap(innerFunction, self) {\n\t    var moveNext = getMoveNext(innerFunction, self);\n\t    var ctx = new GeneratorContext();\n\t    return addIterator({\n\t      next: getNextOrThrow(ctx, moveNext, 'next'),\n\t      throw: getNextOrThrow(ctx, moveNext, 'throw')\n\t    });\n\t  }\n\t  function AsyncFunctionContext() {\n\t    GeneratorContext.call(this);\n\t    this.err = undefined;\n\t    var ctx = this;\n\t    ctx.result = new Promise(function(resolve, reject) {\n\t      ctx.resolve = resolve;\n\t      ctx.reject = reject;\n\t    });\n\t  }\n\t  AsyncFunctionContext.prototype = Object.create(GeneratorContext.prototype);\n\t  function asyncWrap(innerFunction, self) {\n\t    var moveNext = getMoveNext(innerFunction, self);\n\t    var ctx = new AsyncFunctionContext();\n\t    ctx.createCallback = function(newState) {\n\t      return function(value) {\n\t        ctx.state = newState;\n\t        ctx.value = value;\n\t        moveNext(ctx);\n\t      };\n\t    };\n\t    ctx.createErrback = function(newState) {\n\t      return function(err) {\n\t        ctx.state = newState;\n\t        ctx.err = err;\n\t        moveNext(ctx);\n\t      };\n\t    };\n\t    moveNext(ctx);\n\t    return ctx.result;\n\t  }\n\t  function getMoveNext(innerFunction, self) {\n\t    return function(ctx) {\n\t      while (true) {\n\t        try {\n\t          return innerFunction.call(self, ctx);\n\t        } catch (ex) {\n\t          ctx.storedException = ex;\n\t          var last = ctx.tryStack_[ctx.tryStack_.length - 1];\n\t          if (!last) {\n\t            ctx.GState = ST_CLOSED;\n\t            ctx.state = END_STATE;\n\t            throw ex;\n\t          }\n\t          ctx.state = last.catch !== undefined ? last.catch : last.finally;\n\t          if (last.finallyFallThrough !== undefined)\n\t            ctx.finallyFallThrough = last.finallyFallThrough;\n\t        }\n\t      }\n\t    };\n\t  }\n\t  function setupGlobals(global) {\n\t    global.Symbol = Symbol;\n\t    polyfillObject(global.Object);\n\t  }\n\t  setupGlobals(global);\n\t  global.$traceurRuntime = {\n\t    asyncWrap: asyncWrap,\n\t    createClass: createClass,\n\t    defaultSuperCall: defaultSuperCall,\n\t    exportStar: exportStar,\n\t    generatorWrap: generatorWrap,\n\t    setProperty: setProperty,\n\t    setupGlobals: setupGlobals,\n\t    spread: spread,\n\t    superCall: superCall,\n\t    superGet: superGet,\n\t    superSet: superSet,\n\t    toObject: toObject,\n\t    toProperty: toProperty,\n\t    typeof: typeOf\n\t  };\n\t})(typeof global !== 'undefined' ? global : this);\n\t(function() {\n\t  function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n\t    var out = [];\n\t    if (opt_scheme) {\n\t      out.push(opt_scheme, ':');\n\t    }\n\t    if (opt_domain) {\n\t      out.push('//');\n\t      if (opt_userInfo) {\n\t        out.push(opt_userInfo, '@');\n\t      }\n\t      out.push(opt_domain);\n\t      if (opt_port) {\n\t        out.push(':', opt_port);\n\t      }\n\t    }\n\t    if (opt_path) {\n\t      out.push(opt_path);\n\t    }\n\t    if (opt_queryData) {\n\t      out.push('?', opt_queryData);\n\t    }\n\t    if (opt_fragment) {\n\t      out.push('#', opt_fragment);\n\t    }\n\t    return out.join('');\n\t  }\n\t  ;\n\t  var splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\\\?([^#]*))?' + '(?:#(.*))?' + '$');\n\t  var ComponentIndex = {\n\t    SCHEME: 1,\n\t    USER_INFO: 2,\n\t    DOMAIN: 3,\n\t    PORT: 4,\n\t    PATH: 5,\n\t    QUERY_DATA: 6,\n\t    FRAGMENT: 7\n\t  };\n\t  function split(uri) {\n\t    return (uri.match(splitRe));\n\t  }\n\t  function removeDotSegments(path) {\n\t    if (path === '/')\n\t      return '/';\n\t    var leadingSlash = path[0] === '/' ? '/' : '';\n\t    var trailingSlash = path.slice(-1) === '/' ? '/' : '';\n\t    var segments = path.split('/');\n\t    var out = [];\n\t    var up = 0;\n\t    for (var pos = 0; pos < segments.length; pos++) {\n\t      var segment = segments[pos];\n\t      switch (segment) {\n\t        case '':\n\t        case '.':\n\t          break;\n\t        case '..':\n\t          if (out.length)\n\t            out.pop();\n\t          else\n\t            up++;\n\t          break;\n\t        default:\n\t          out.push(segment);\n\t      }\n\t    }\n\t    if (!leadingSlash) {\n\t      while (up-- > 0) {\n\t        out.unshift('..');\n\t      }\n\t      if (out.length === 0)\n\t        out.push('.');\n\t    }\n\t    return leadingSlash + out.join('/') + trailingSlash;\n\t  }\n\t  function joinAndCanonicalizePath(parts) {\n\t    var path = parts[ComponentIndex.PATH] || '';\n\t    path = removeDotSegments(path.replace(/\\/\\//.g, '/'));\n\t    parts[ComponentIndex.PATH] = path;\n\t    return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);\n\t  }\n\t  function canonicalizeUrl(url) {\n\t    var parts = split(url);\n\t    return joinAndCanonicalizePath(parts);\n\t  }\n\t  function resolveUrl(base, url) {\n\t    var parts = split(url);\n\t    var baseParts = split(base);\n\t    if (parts[ComponentIndex.SCHEME]) {\n\t      return joinAndCanonicalizePath(parts);\n\t    } else {\n\t      parts[ComponentIndex.SCHEME] = baseParts[ComponentIndex.SCHEME];\n\t    }\n\t    for (var i = ComponentIndex.SCHEME; i <= ComponentIndex.PORT; i++) {\n\t      if (!parts[i]) {\n\t        parts[i] = baseParts[i];\n\t      }\n\t    }\n\t    if (parts[ComponentIndex.PATH][0] == '/') {\n\t      return joinAndCanonicalizePath(parts);\n\t    }\n\t    var path = baseParts[ComponentIndex.PATH];\n\t    var index = path.lastIndexOf('/');\n\t    path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];\n\t    parts[ComponentIndex.PATH] = path;\n\t    return joinAndCanonicalizePath(parts);\n\t  }\n\t  function isAbsolute(name) {\n\t    if (!name)\n\t      return false;\n\t    if (name[0] === '/')\n\t      return true;\n\t    var parts = split(name);\n\t    if (parts[ComponentIndex.SCHEME])\n\t      return true;\n\t    return false;\n\t  }\n\t  $traceurRuntime.canonicalizeUrl = canonicalizeUrl;\n\t  $traceurRuntime.isAbsolute = isAbsolute;\n\t  $traceurRuntime.removeDotSegments = removeDotSegments;\n\t  $traceurRuntime.resolveUrl = resolveUrl;\n\t})();\n\t(function(global) {\n\t  'use strict';\n\t  var $__2 = $traceurRuntime,\n\t      canonicalizeUrl = $__2.canonicalizeUrl,\n\t      resolveUrl = $__2.resolveUrl,\n\t      isAbsolute = $__2.isAbsolute;\n\t  var moduleInstantiators = Object.create(null);\n\t  var baseURL;\n\t  if (global.location && global.location.href)\n\t    baseURL = resolveUrl(global.location.href, './');\n\t  else\n\t    baseURL = '';\n\t  var UncoatedModuleEntry = function UncoatedModuleEntry(url, uncoatedModule) {\n\t    this.url = url;\n\t    this.value_ = uncoatedModule;\n\t  };\n\t  ($traceurRuntime.createClass)(UncoatedModuleEntry, {}, {});\n\t  var UncoatedModuleInstantiator = function UncoatedModuleInstantiator(url, func) {\n\t    $traceurRuntime.superCall(this, $UncoatedModuleInstantiator.prototype, \"constructor\", [url, null]);\n\t    this.func = func;\n\t  };\n\t  var $UncoatedModuleInstantiator = UncoatedModuleInstantiator;\n\t  ($traceurRuntime.createClass)(UncoatedModuleInstantiator, {getUncoatedModule: function() {\n\t      if (this.value_)\n\t        return this.value_;\n\t      return this.value_ = this.func.call(global);\n\t    }}, {}, UncoatedModuleEntry);\n\t  function getUncoatedModuleInstantiator(name) {\n\t    if (!name)\n\t      return;\n\t    var url = ModuleStore.normalize(name);\n\t    return moduleInstantiators[url];\n\t  }\n\t  ;\n\t  var moduleInstances = Object.create(null);\n\t  var liveModuleSentinel = {};\n\t  function Module(uncoatedModule) {\n\t    var isLive = arguments[1];\n\t    var coatedModule = Object.create(null);\n\t    Object.getOwnPropertyNames(uncoatedModule).forEach((function(name) {\n\t      var getter,\n\t          value;\n\t      if (isLive === liveModuleSentinel) {\n\t        var descr = Object.getOwnPropertyDescriptor(uncoatedModule, name);\n\t        if (descr.get)\n\t          getter = descr.get;\n\t      }\n\t      if (!getter) {\n\t        value = uncoatedModule[name];\n\t        getter = function() {\n\t          return value;\n\t        };\n\t      }\n\t      Object.defineProperty(coatedModule, name, {\n\t        get: getter,\n\t        enumerable: true\n\t      });\n\t    }));\n\t    Object.preventExtensions(coatedModule);\n\t    return coatedModule;\n\t  }\n\t  var ModuleStore = {\n\t    normalize: function(name, refererName, refererAddress) {\n\t      if (typeof name !== \"string\")\n\t        throw new TypeError(\"module name must be a string, not \" + typeof name);\n\t      if (isAbsolute(name))\n\t        return canonicalizeUrl(name);\n\t      if (/[^\\.]\\/\\.\\.\\//.test(name)) {\n\t        throw new Error('module name embeds /../: ' + name);\n\t      }\n\t      if (name[0] === '.' && refererName)\n\t        return resolveUrl(refererName, name);\n\t      return canonicalizeUrl(name);\n\t    },\n\t    get: function(normalizedName) {\n\t      var m = getUncoatedModuleInstantiator(normalizedName);\n\t      if (!m)\n\t        return undefined;\n\t      var moduleInstance = moduleInstances[m.url];\n\t      if (moduleInstance)\n\t        return moduleInstance;\n\t      moduleInstance = Module(m.getUncoatedModule(), liveModuleSentinel);\n\t      return moduleInstances[m.url] = moduleInstance;\n\t    },\n\t    set: function(normalizedName, module) {\n\t      normalizedName = String(normalizedName);\n\t      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, (function() {\n\t        return module;\n\t      }));\n\t      moduleInstances[normalizedName] = module;\n\t    },\n\t    get baseURL() {\n\t      return baseURL;\n\t    },\n\t    set baseURL(v) {\n\t      baseURL = String(v);\n\t    },\n\t    registerModule: function(name, func) {\n\t      var normalizedName = ModuleStore.normalize(name);\n\t      if (moduleInstantiators[normalizedName])\n\t        throw new Error('duplicate module named ' + normalizedName);\n\t      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, func);\n\t    },\n\t    bundleStore: Object.create(null),\n\t    register: function(name, deps, func) {\n\t      if (!deps || !deps.length) {\n\t        this.registerModule(name, func);\n\t      } else {\n\t        this.bundleStore[name] = {\n\t          deps: deps,\n\t          execute: func\n\t        };\n\t      }\n\t    },\n\t    getAnonymousModule: function(func) {\n\t      return new Module(func.call(global), liveModuleSentinel);\n\t    },\n\t    getForTesting: function(name) {\n\t      var $__0 = this;\n\t      if (!this.testingPrefix_) {\n\t        Object.keys(moduleInstances).some((function(key) {\n\t          var m = /(traceur@[^\\/]*\\/)/.exec(key);\n\t          if (m) {\n\t            $__0.testingPrefix_ = m[1];\n\t            return true;\n\t          }\n\t        }));\n\t      }\n\t      return this.get(this.testingPrefix_ + name);\n\t    }\n\t  };\n\t  ModuleStore.set('@traceur/src/runtime/ModuleStore', new Module({ModuleStore: ModuleStore}));\n\t  var setupGlobals = $traceurRuntime.setupGlobals;\n\t  $traceurRuntime.setupGlobals = function(global) {\n\t    setupGlobals(global);\n\t  };\n\t  $traceurRuntime.ModuleStore = ModuleStore;\n\t  global.System = {\n\t    register: ModuleStore.register.bind(ModuleStore),\n\t    get: ModuleStore.get,\n\t    set: ModuleStore.set,\n\t    normalize: ModuleStore.normalize\n\t  };\n\t  $traceurRuntime.getModuleImpl = function(name) {\n\t    var instantiator = getUncoatedModuleInstantiator(name);\n\t    return instantiator && instantiator.getUncoatedModule();\n\t  };\n\t})(typeof global !== 'undefined' ? global : this);\n\tSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/utils\", [], function() {\n\t  \"use strict\";\n\t  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/utils\";\n\t  var toObject = $traceurRuntime.toObject;\n\t  function toUint32(x) {\n\t    return x | 0;\n\t  }\n\t  return {\n\t    get toObject() {\n\t      return toObject;\n\t    },\n\t    get toUint32() {\n\t      return toUint32;\n\t    }\n\t  };\n\t});\n\tSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/ArrayIterator\", [], function() {\n\t  \"use strict\";\n\t  var $__4;\n\t  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/ArrayIterator\";\n\t  var $__5 = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/utils\"),\n\t      toObject = $__5.toObject,\n\t      toUint32 = $__5.toUint32;\n\t  var ARRAY_ITERATOR_KIND_KEYS = 1;\n\t  var ARRAY_ITERATOR_KIND_VALUES = 2;\n\t  var ARRAY_ITERATOR_KIND_ENTRIES = 3;\n\t  var ArrayIterator = function ArrayIterator() {};\n\t  ($traceurRuntime.createClass)(ArrayIterator, ($__4 = {}, Object.defineProperty($__4, \"next\", {\n\t    value: function() {\n\t      var iterator = toObject(this);\n\t      var array = iterator.iteratorObject_;\n\t      if (!array) {\n\t        throw new TypeError('Object is not an ArrayIterator');\n\t      }\n\t      var index = iterator.arrayIteratorNextIndex_;\n\t      var itemKind = iterator.arrayIterationKind_;\n\t      var length = toUint32(array.length);\n\t      if (index >= length) {\n\t        iterator.arrayIteratorNextIndex_ = Infinity;\n\t        return createIteratorResultObject(undefined, true);\n\t      }\n\t      iterator.arrayIteratorNextIndex_ = index + 1;\n\t      if (itemKind == ARRAY_ITERATOR_KIND_VALUES)\n\t        return createIteratorResultObject(array[index], false);\n\t      if (itemKind == ARRAY_ITERATOR_KIND_ENTRIES)\n\t        return createIteratorResultObject([index, array[index]], false);\n\t      return createIteratorResultObject(index, false);\n\t    },\n\t    configurable: true,\n\t    enumerable: true,\n\t    writable: true\n\t  }), Object.defineProperty($__4, Symbol.iterator, {\n\t    value: function() {\n\t      return this;\n\t    },\n\t    configurable: true,\n\t    enumerable: true,\n\t    writable: true\n\t  }), $__4), {});\n\t  function createArrayIterator(array, kind) {\n\t    var object = toObject(array);\n\t    var iterator = new ArrayIterator;\n\t    iterator.iteratorObject_ = object;\n\t    iterator.arrayIteratorNextIndex_ = 0;\n\t    iterator.arrayIterationKind_ = kind;\n\t    return iterator;\n\t  }\n\t  function createIteratorResultObject(value, done) {\n\t    return {\n\t      value: value,\n\t      done: done\n\t    };\n\t  }\n\t  function entries() {\n\t    return createArrayIterator(this, ARRAY_ITERATOR_KIND_ENTRIES);\n\t  }\n\t  function keys() {\n\t    return createArrayIterator(this, ARRAY_ITERATOR_KIND_KEYS);\n\t  }\n\t  function values() {\n\t    return createArrayIterator(this, ARRAY_ITERATOR_KIND_VALUES);\n\t  }\n\t  return {\n\t    get entries() {\n\t      return entries;\n\t    },\n\t    get keys() {\n\t      return keys;\n\t    },\n\t    get values() {\n\t      return values;\n\t    }\n\t  };\n\t});\n\tSystem.register(\"traceur-runtime@0.0.25/node_modules/rsvp/lib/rsvp/asap\", [], function() {\n\t  \"use strict\";\n\t  var __moduleName = \"traceur-runtime@0.0.25/node_modules/rsvp/lib/rsvp/asap\";\n\t  var $__default = function asap(callback, arg) {\n\t    var length = queue.push([callback, arg]);\n\t    if (length === 1) {\n\t      scheduleFlush();\n\t    }\n\t  };\n\t  var browserGlobal = (typeof window !== 'undefined') ? window : {};\n\t  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\n\t  function useNextTick() {\n\t    return function() {\n\t      process.nextTick(flush);\n\t    };\n\t  }\n\t  function useMutationObserver() {\n\t    var iterations = 0;\n\t    var observer = new BrowserMutationObserver(flush);\n\t    var node = document.createTextNode('');\n\t    observer.observe(node, {characterData: true});\n\t    return function() {\n\t      node.data = (iterations = ++iterations % 2);\n\t    };\n\t  }\n\t  function useSetTimeout() {\n\t    return function() {\n\t      setTimeout(flush, 1);\n\t    };\n\t  }\n\t  var queue = [];\n\t  function flush() {\n\t    for (var i = 0; i < queue.length; i++) {\n\t      var tuple = queue[i];\n\t      var callback = tuple[0],\n\t          arg = tuple[1];\n\t      callback(arg);\n\t    }\n\t    queue = [];\n\t  }\n\t  var scheduleFlush;\n\t  if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n\t    scheduleFlush = useNextTick();\n\t  } else if (BrowserMutationObserver) {\n\t    scheduleFlush = useMutationObserver();\n\t  } else {\n\t    scheduleFlush = useSetTimeout();\n\t  }\n\t  return {get default() {\n\t      return $__default;\n\t    }};\n\t});\n\tSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/Promise\", [], function() {\n\t  \"use strict\";\n\t  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/Promise\";\n\t  var async = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/node_modules/rsvp/lib/rsvp/asap\").default;\n\t  function isPromise(x) {\n\t    return x && typeof x === 'object' && x.status_ !== undefined;\n\t  }\n\t  function chain(promise) {\n\t    var onResolve = arguments[1] !== (void 0) ? arguments[1] : (function(x) {\n\t      return x;\n\t    });\n\t    var onReject = arguments[2] !== (void 0) ? arguments[2] : (function(e) {\n\t      throw e;\n\t    });\n\t    var deferred = getDeferred(promise.constructor);\n\t    switch (promise.status_) {\n\t      case undefined:\n\t        throw TypeError;\n\t      case 'pending':\n\t        promise.onResolve_.push([deferred, onResolve]);\n\t        promise.onReject_.push([deferred, onReject]);\n\t        break;\n\t      case 'resolved':\n\t        promiseReact(deferred, onResolve, promise.value_);\n\t        break;\n\t      case 'rejected':\n\t        promiseReact(deferred, onReject, promise.value_);\n\t        break;\n\t    }\n\t    return deferred.promise;\n\t  }\n\t  function getDeferred(C) {\n\t    var result = {};\n\t    result.promise = new C((function(resolve, reject) {\n\t      result.resolve = resolve;\n\t      result.reject = reject;\n\t    }));\n\t    return result;\n\t  }\n\t  var Promise = function Promise(resolver) {\n\t    var $__6 = this;\n\t    this.status_ = 'pending';\n\t    this.onResolve_ = [];\n\t    this.onReject_ = [];\n\t    resolver((function(x) {\n\t      promiseResolve($__6, x);\n\t    }), (function(r) {\n\t      promiseReject($__6, r);\n\t    }));\n\t  };\n\t  ($traceurRuntime.createClass)(Promise, {\n\t    catch: function(onReject) {\n\t      return this.then(undefined, onReject);\n\t    },\n\t    then: function() {\n\t      var onResolve = arguments[0] !== (void 0) ? arguments[0] : (function(x) {\n\t        return x;\n\t      });\n\t      var onReject = arguments[1];\n\t      var $__6 = this;\n\t      var constructor = this.constructor;\n\t      return chain(this, (function(x) {\n\t        x = promiseCoerce(constructor, x);\n\t        return x === $__6 ? onReject(new TypeError) : isPromise(x) ? x.then(onResolve, onReject) : onResolve(x);\n\t      }), onReject);\n\t    }\n\t  }, {\n\t    resolve: function(x) {\n\t      return new this((function(resolve, reject) {\n\t        resolve(x);\n\t      }));\n\t    },\n\t    reject: function(r) {\n\t      return new this((function(resolve, reject) {\n\t        reject(r);\n\t      }));\n\t    },\n\t    cast: function(x) {\n\t      if (x instanceof this)\n\t        return x;\n\t      if (isPromise(x)) {\n\t        var result = getDeferred(this);\n\t        chain(x, result.resolve, result.reject);\n\t        return result.promise;\n\t      }\n\t      return this.resolve(x);\n\t    },\n\t    all: function(values) {\n\t      var deferred = getDeferred(this);\n\t      var count = 0;\n\t      var resolutions = [];\n\t      try {\n\t        for (var i = 0; i < values.length; i++) {\n\t          ++count;\n\t          this.cast(values[i]).then(function(i, x) {\n\t            resolutions[i] = x;\n\t            if (--count === 0)\n\t              deferred.resolve(resolutions);\n\t          }.bind(undefined, i), (function(r) {\n\t            if (count > 0)\n\t              count = 0;\n\t            deferred.reject(r);\n\t          }));\n\t        }\n\t        if (count === 0)\n\t          deferred.resolve(resolutions);\n\t      } catch (e) {\n\t        deferred.reject(e);\n\t      }\n\t      return deferred.promise;\n\t    },\n\t    race: function(values) {\n\t      var deferred = getDeferred(this);\n\t      try {\n\t        for (var i = 0; i < values.length; i++) {\n\t          this.cast(values[i]).then((function(x) {\n\t            deferred.resolve(x);\n\t          }), (function(r) {\n\t            deferred.reject(r);\n\t          }));\n\t        }\n\t      } catch (e) {\n\t        deferred.reject(e);\n\t      }\n\t      return deferred.promise;\n\t    }\n\t  });\n\t  function promiseResolve(promise, x) {\n\t    promiseDone(promise, 'resolved', x, promise.onResolve_);\n\t  }\n\t  function promiseReject(promise, r) {\n\t    promiseDone(promise, 'rejected', r, promise.onReject_);\n\t  }\n\t  function promiseDone(promise, status, value, reactions) {\n\t    if (promise.status_ !== 'pending')\n\t      return;\n\t    for (var i = 0; i < reactions.length; i++) {\n\t      promiseReact(reactions[i][0], reactions[i][1], value);\n\t    }\n\t    promise.status_ = status;\n\t    promise.value_ = value;\n\t    promise.onResolve_ = promise.onReject_ = undefined;\n\t  }\n\t  function promiseReact(deferred, handler, x) {\n\t    async((function() {\n\t      try {\n\t        var y = handler(x);\n\t        if (y === deferred.promise)\n\t          throw new TypeError;\n\t        else if (isPromise(y))\n\t          chain(y, deferred.resolve, deferred.reject);\n\t        else\n\t          deferred.resolve(y);\n\t      } catch (e) {\n\t        deferred.reject(e);\n\t      }\n\t    }));\n\t  }\n\t  var thenableSymbol = '@@thenable';\n\t  function promiseCoerce(constructor, x) {\n\t    if (isPromise(x)) {\n\t      return x;\n\t    } else if (x && typeof x.then === 'function') {\n\t      var p = x[thenableSymbol];\n\t      if (p) {\n\t        return p;\n\t      } else {\n\t        var deferred = getDeferred(constructor);\n\t        x[thenableSymbol] = deferred.promise;\n\t        try {\n\t          x.then(deferred.resolve, deferred.reject);\n\t        } catch (e) {\n\t          deferred.reject(e);\n\t        }\n\t        return deferred.promise;\n\t      }\n\t    } else {\n\t      return x;\n\t    }\n\t  }\n\t  return {get Promise() {\n\t      return Promise;\n\t    }};\n\t});\n\tSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/String\", [], function() {\n\t  \"use strict\";\n\t  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/String\";\n\t  var $toString = Object.prototype.toString;\n\t  var $indexOf = String.prototype.indexOf;\n\t  var $lastIndexOf = String.prototype.lastIndexOf;\n\t  function startsWith(search) {\n\t    var string = String(this);\n\t    if (this == null || $toString.call(search) == '[object RegExp]') {\n\t      throw TypeError();\n\t    }\n\t    var stringLength = string.length;\n\t    var searchString = String(search);\n\t    var searchLength = searchString.length;\n\t    var position = arguments.length > 1 ? arguments[1] : undefined;\n\t    var pos = position ? Number(position) : 0;\n\t    if (isNaN(pos)) {\n\t      pos = 0;\n\t    }\n\t    var start = Math.min(Math.max(pos, 0), stringLength);\n\t    return $indexOf.call(string, searchString, pos) == start;\n\t  }\n\t  function endsWith(search) {\n\t    var string = String(this);\n\t    if (this == null || $toString.call(search) == '[object RegExp]') {\n\t      throw TypeError();\n\t    }\n\t    var stringLength = string.length;\n\t    var searchString = String(search);\n\t    var searchLength = searchString.length;\n\t    var pos = stringLength;\n\t    if (arguments.length > 1) {\n\t      var position = arguments[1];\n\t      if (position !== undefined) {\n\t        pos = position ? Number(position) : 0;\n\t        if (isNaN(pos)) {\n\t          pos = 0;\n\t        }\n\t      }\n\t    }\n\t    var end = Math.min(Math.max(pos, 0), stringLength);\n\t    var start = end - searchLength;\n\t    if (start < 0) {\n\t      return false;\n\t    }\n\t    return $lastIndexOf.call(string, searchString, start) == start;\n\t  }\n\t  function contains(search) {\n\t    if (this == null) {\n\t      throw TypeError();\n\t    }\n\t    var string = String(this);\n\t    var stringLength = string.length;\n\t    var searchString = String(search);\n\t    var searchLength = searchString.length;\n\t    var position = arguments.length > 1 ? arguments[1] : undefined;\n\t    var pos = position ? Number(position) : 0;\n\t    if (isNaN(pos)) {\n\t      pos = 0;\n\t    }\n\t    var start = Math.min(Math.max(pos, 0), stringLength);\n\t    return $indexOf.call(string, searchString, pos) != -1;\n\t  }\n\t  function repeat(count) {\n\t    if (this == null) {\n\t      throw TypeError();\n\t    }\n\t    var string = String(this);\n\t    var n = count ? Number(count) : 0;\n\t    if (isNaN(n)) {\n\t      n = 0;\n\t    }\n\t    if (n < 0 || n == Infinity) {\n\t      throw RangeError();\n\t    }\n\t    if (n == 0) {\n\t      return '';\n\t    }\n\t    var result = '';\n\t    while (n--) {\n\t      result += string;\n\t    }\n\t    return result;\n\t  }\n\t  function codePointAt(position) {\n\t    if (this == null) {\n\t      throw TypeError();\n\t    }\n\t    var string = String(this);\n\t    var size = string.length;\n\t    var index = position ? Number(position) : 0;\n\t    if (isNaN(index)) {\n\t      index = 0;\n\t    }\n\t    if (index < 0 || index >= size) {\n\t      return undefined;\n\t    }\n\t    var first = string.charCodeAt(index);\n\t    var second;\n\t    if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {\n\t      second = string.charCodeAt(index + 1);\n\t      if (second >= 0xDC00 && second <= 0xDFFF) {\n\t        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t      }\n\t    }\n\t    return first;\n\t  }\n\t  function raw(callsite) {\n\t    var raw = callsite.raw;\n\t    var len = raw.length >>> 0;\n\t    if (len === 0)\n\t      return '';\n\t    var s = '';\n\t    var i = 0;\n\t    while (true) {\n\t      s += raw[i];\n\t      if (i + 1 === len)\n\t        return s;\n\t      s += arguments[++i];\n\t    }\n\t  }\n\t  function fromCodePoint() {\n\t    var codeUnits = [];\n\t    var floor = Math.floor;\n\t    var highSurrogate;\n\t    var lowSurrogate;\n\t    var index = -1;\n\t    var length = arguments.length;\n\t    if (!length) {\n\t      return '';\n\t    }\n\t    while (++index < length) {\n\t      var codePoint = Number(arguments[index]);\n\t      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {\n\t        throw RangeError('Invalid code point: ' + codePoint);\n\t      }\n\t      if (codePoint <= 0xFFFF) {\n\t        codeUnits.push(codePoint);\n\t      } else {\n\t        codePoint -= 0x10000;\n\t        highSurrogate = (codePoint >> 10) + 0xD800;\n\t        lowSurrogate = (codePoint % 0x400) + 0xDC00;\n\t        codeUnits.push(highSurrogate, lowSurrogate);\n\t      }\n\t    }\n\t    return String.fromCharCode.apply(null, codeUnits);\n\t  }\n\t  return {\n\t    get startsWith() {\n\t      return startsWith;\n\t    },\n\t    get endsWith() {\n\t      return endsWith;\n\t    },\n\t    get contains() {\n\t      return contains;\n\t    },\n\t    get repeat() {\n\t      return repeat;\n\t    },\n\t    get codePointAt() {\n\t      return codePointAt;\n\t    },\n\t    get raw() {\n\t      return raw;\n\t    },\n\t    get fromCodePoint() {\n\t      return fromCodePoint;\n\t    }\n\t  };\n\t});\n\tSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/polyfills\", [], function() {\n\t  \"use strict\";\n\t  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/polyfills\";\n\t  var Promise = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/Promise\").Promise;\n\t  var $__9 = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/String\"),\n\t      codePointAt = $__9.codePointAt,\n\t      contains = $__9.contains,\n\t      endsWith = $__9.endsWith,\n\t      fromCodePoint = $__9.fromCodePoint,\n\t      repeat = $__9.repeat,\n\t      raw = $__9.raw,\n\t      startsWith = $__9.startsWith;\n\t  var $__9 = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/ArrayIterator\"),\n\t      entries = $__9.entries,\n\t      keys = $__9.keys,\n\t      values = $__9.values;\n\t  function maybeDefineMethod(object, name, value) {\n\t    if (!(name in object)) {\n\t      Object.defineProperty(object, name, {\n\t        value: value,\n\t        configurable: true,\n\t        enumerable: false,\n\t        writable: true\n\t      });\n\t    }\n\t  }\n\t  function maybeAddFunctions(object, functions) {\n\t    for (var i = 0; i < functions.length; i += 2) {\n\t      var name = functions[i];\n\t      var value = functions[i + 1];\n\t      maybeDefineMethod(object, name, value);\n\t    }\n\t  }\n\t  function polyfillPromise(global) {\n\t    if (!global.Promise)\n\t      global.Promise = Promise;\n\t  }\n\t  function polyfillString(String) {\n\t    maybeAddFunctions(String.prototype, ['codePointAt', codePointAt, 'contains', contains, 'endsWith', endsWith, 'startsWith', startsWith, 'repeat', repeat]);\n\t    maybeAddFunctions(String, ['fromCodePoint', fromCodePoint, 'raw', raw]);\n\t  }\n\t  function polyfillArray(Array, Symbol) {\n\t    maybeAddFunctions(Array.prototype, ['entries', entries, 'keys', keys, 'values', values]);\n\t    if (Symbol && Symbol.iterator) {\n\t      Object.defineProperty(Array.prototype, Symbol.iterator, {\n\t        value: values,\n\t        configurable: true,\n\t        enumerable: false,\n\t        writable: true\n\t      });\n\t    }\n\t  }\n\t  function polyfill(global) {\n\t    polyfillPromise(global);\n\t    polyfillString(global.String);\n\t    polyfillArray(global.Array, global.Symbol);\n\t  }\n\t  polyfill(this);\n\t  var setupGlobals = $traceurRuntime.setupGlobals;\n\t  $traceurRuntime.setupGlobals = function(global) {\n\t    setupGlobals(global);\n\t    polyfill(global);\n\t  };\n\t  return {};\n\t});\n\tSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfill-import\", [], function() {\n\t  \"use strict\";\n\t  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfill-import\";\n\t  var $__11 = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/polyfills\");\n\t  return {};\n\t});\n\tSystem.get(\"traceur-runtime@0.0.25/src/runtime/polyfill-import\" + '');\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(22)))\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"9ac7e2ff6b9792291e65269b982efa35.otf\"\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"09ad3649cefc511e2e20b98991116a59.otf\"\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"f0d7d673ef06ec9cf090dc00572d63e4.otf\"\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"f02f3b1af0eda2c88d9a7ae67234c564.otf\"\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"819f56653a4197a7959c41ddfc8ff69b.ttf\"\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"9ac6e3d2a7fb76468bd417ea40b6f8c4.ttf\"\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"3bb8cd188e88dfe3b75c26c86dae0d79.svg\"\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"e17c44b2d6689463899b823f3201f837.svg\"\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\t\n\tprocess.nextTick = (function () {\n\t    var canSetImmediate = typeof window !== 'undefined'\n\t    && window.setImmediate;\n\t    var canPost = typeof window !== 'undefined'\n\t    && window.postMessage && window.addEventListener\n\t    ;\n\t\n\t    if (canSetImmediate) {\n\t        return function (f) { return window.setImmediate(f) };\n\t    }\n\t\n\t    if (canPost) {\n\t        var queue = [];\n\t        window.addEventListener('message', function (ev) {\n\t            var source = ev.source;\n\t            if ((source === window || source === null) && ev.data === 'process-tick') {\n\t                ev.stopPropagation();\n\t                if (queue.length > 0) {\n\t                    var fn = queue.shift();\n\t                    fn();\n\t                }\n\t            }\n\t        }, true);\n\t\n\t        return function nextTick(fn) {\n\t            queue.push(fn);\n\t            window.postMessage('process-tick', '*');\n\t        };\n\t    }\n\t\n\t    return function nextTick(fn) {\n\t        setTimeout(fn, 0);\n\t    };\n\t})();\n\t\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t}\n\t\n\t// TODO(shtylman)\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\n\n/***/ }\n/******/ ])\n\n\n/** WEBPACK FOOTER **\n ** pink.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/pink/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 2f0040630425f61b8dde\n **/","var Pink = require(\"pink\");\n\nnew Pink(\"#slides\", {\n  \"background\": require(\"pink/modules/background\"),\n  \"image\": require(\"pink/modules/image\")\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./slides.js\n ** module id = 0\n ** module chunks = 0\n **/","// Thanks http://lea.verou.me/2009/02/find-the-vendor-prefix-of-the-current-browser/\nvar cachedPrefix = null;\n\nfunction getPrefix() {\n  if (cachedPrefix) return cachedPrefix;\n  const regex = /^(Moz|Webkit|Khtml|O|ms|Icab)(?=[A-Z])/;\n  const elem = document.body;\n  for (let prop in elem.style) {\n    if (regex.test(prop)) {\n      return cachedPrefix = prop.match(regex)[0];\n    }\n  }\n  if (\"WebkitOpacity\" in elem.style) {\n    return cachedPrefix = \"Webkit\";\n  }\n  if (\"KhtmlOpacity\" in elem.style) {\n    return cachedPrefix = \"Khtml\";\n  }\n  return cachedPrefix = \"\";\n}\n\nvar cachedEvents = {};\n\nfunction vendorPrefix(prop) {\n  if (cachedEvents.hasOwnProperty(prop)) return cachedEvents[prop];\n  const vp = getPrefix().toLowerCase();\n  const pp = (vp) ? (vp + prop) : prop.toLowerCase();\n  cachedEvents[prop] = pp;\n  return pp;\n}\n\n// Register to receive events.\nfunction on(emitter, eventName, handler, context) {\n  handler = context ? handler.bind(context) : handler;\n  emitter.addEventListener(eventName, handler);\n  return handler;\n}\n\n// Register to receive one single event.\nfunction once(emitter, eventName, handler, context) {\n  handler = context ? handler.bind(context) : handler;\n  let wrapper = function onceHandler(event) {\n    emitter.removeEventListener(eventName, onceHandler);\n    handler(event);\n  };\n  emitter.addEventListener(eventName, wrapper);\n  return wrapper;\n}\n\n// Register to receive events until the handler function returns true.\nfunction until(emitter, eventName, handler, context) {\n  handler = context ? handler.bind(context) : handler;\n  let wrapper = function untilHandler(event) {\n    if (handler(event))\n      emitter.removeEventListener(eventName, untilHandler);\n  };\n  emitter.addEventListener(eventName, wrapper);\n  return wrapper;\n}\n\n// Unregister an event handler.\nfunction off(emitter, eventName, handler) {\n  emitter.removeEventListener(eventName, handler);\n}\n\nmodule.exports = {\n  on: on, once: once, until: until, off: off, vendorPrefix: vendorPrefix\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ../pink/lib/events.es6\n **/","$__placeholder__0[$traceurRuntime.toProperty($__placeholder__1)]\n\n\n/** WEBPACK FOOTER **\n ** @traceur/generated/TemplateParser/2\n **/","$traceurRuntime.toProperty($__placeholder__0) in $__placeholder__1\n\n\n/** WEBPACK FOOTER **\n ** @traceur/generated/TemplateParser/5\n **/","$traceurRuntime.setProperty($__placeholder__0,\n          $__placeholder__1, $__placeholder__2)\n\n\n/** WEBPACK FOOTER **\n ** @traceur/generated/TemplateParser/6\n **/","var __moduleName = $__placeholder__0;\n\n\n/** WEBPACK FOOTER **\n ** @traceur/generated/TemplateParser/0\n **/","/*global setTimeout */\n\n// Patch in Traceur runtime\nwindow.global = window;\nrequire(\"traceur/bin/traceur-runtime\");\n\nrequire(\"./css/screen.less\");\n\nvar mousetrap = require(\"./lib/mousetrap\");\nvar hammer = require(\"hammerjs\");\nvar events = require(\"./lib/events\");\nvar seq = require(\"./lib/seq\");\n\nfunction Deck(container, deckModules) {\n\n  if (typeof container === \"string\") {\n    container = document.querySelector(container);\n  }\n\n  const slides = seq.toArray(container.querySelectorAll(\"section\"));\n  this.currentSlide = null;\n  this.currentItem = null;\n\n  const stream = seq.flatMap((slide) => {\n    return [slide].concat(seq.toArray(slide.querySelectorAll(\".fragment\")));\n  }, slides);\n\n  function isFragment(node) {\n    return node.classList.contains(\"fragment\");\n  }\n\n  function fragmentSlide(node) {\n    if (isFragment(node)) {\n      while (node.nodeName !== \"SECTION\") {\n        node = node.parentNode;\n      }\n    }\n    return node;\n  }\n\n  slides.forEach((slide) => {\n    const children = seq.toArray(slide.childNodes);\n    const container = document.createElement(\"div\");\n    container.classList.add(\"slideContainer\");\n    children.forEach((child) => {\n      slide.removeChild(child);\n      container.appendChild(child);\n    });\n    slide.appendChild(container);\n  });\n\n  this.deactivateSlide = (slide) => {\n    if (slide.classList.contains(\"current\")) {\n      slide.classList.add(\"out\");\n      slide.classList.remove(\"current\");\n    }\n    this.currentSlide = null;\n  }\n\n  this.activateSlide = (slide) => {\n    if (slide.classList.contains(\"out\")) {\n      this.cleanupModules(slide);\n      slide.classList.remove(\"out\");\n    }\n    if (this.currentSlide !== null) this.deactivateSlide(this.currentSlide);\n    this.currentSlide = slide;\n\n    this.activateModules(slide);\n\n    slide.classList.add(\"current\");\n    slide.classList.add(\"in\");\n  }\n\n  function applyFragment(from, to, f) {\n    var node;\n    for (let i = from; i <= to; i++) {\n      node = stream[i];\n      if (isFragment(node)) {\n        f(node);\n      }\n    }\n  }\n\n  this.activateItem = (item) => {\n    let itemSlide = fragmentSlide(stream[item]);\n    if (this.currentItem !== null) {\n      if (this.currentItem < item) {\n        applyFragment(this.currentItem, item,\n                      (node) => node.classList.add(\"active\"));\n      } else if (this.currentItem > item) {\n        applyFragment(item + 1, this.currentItem,\n                      (node) => node.classList.remove(\"active\"));\n      }\n    } else {\n      applyFragment(0, item, (node) => node.classList.add(\"active\"));\n      applyFragment(item + 1, stream.length - 1,\n                    (node) => node.classList.remove(\"active\"));\n    }\n    this.currentItem = item;\n    if (this.currentSlide !== itemSlide) {\n      this.activateSlide(itemSlide);\n    }\n    window.location.hash = \"\" + this.currentItem;\n  };\n\n  this.nextItem = () => {\n    let nextItem = this.currentItem !== null ? this.currentItem + 1 : 0;\n    if (nextItem >= stream.length) nextItem = stream.length - 1;\n    if (nextItem !== this.currentItem) this.activateItem(nextItem);\n  }\n\n  this.previousItem = () => {\n    let prevItem = this.currentItem !== null ? this.currentItem - 1 : 0;\n    if (prevItem < 0) prevItem = 0;\n    if (prevItem !== this.currentItem) this.activateItem(prevItem);\n  }\n\n  this.initModules = (slide) => {\n    let slideData = slide.dataset,\n        deckData = container.dataset;\n    let mods = [], mod;\n    for (mod in deckModules) {\n      if (deckModules.hasOwnProperty(mod)) {\n        let arg = slideData.hasOwnProperty(mod) ? slideData[mod] :\n              deckData.hasOwnProperty(mod) ? deckData[mod] : null;\n        if (arg) mods.push(new deckModules[mod](slide, arg));\n      }\n    }\n    slide._deck_modules = mods;\n  }\n\n  this.activateModules = (slide) => {\n    slide._deck_modules.forEach((mod) => mod.activate && mod.activate());\n  }\n\n  this.stabiliseModules = (slide) => {\n    slide._deck_modules.forEach((mod) => mod.stabilise && mod.stabilise());\n  }\n\n  this.cleanupModules = (slide) => {\n    slide._deck_modules.forEach((mod) => mod.cleanup && mod.cleanup());\n  }\n\n  this.transitionEnd = (e) => {\n    let slide = e.target;\n    if (slide.classList.contains(\"out\")) {\n      slide.classList.remove(\"out\");\n      this.cleanupModules(slide);\n    } else if (slide.classList.contains(\"in\")) {\n      slide.classList.remove(\"in\");\n      this.stabiliseModules(slide);\n    }\n  }\n\n  this.rescale = () => {\n    const screenw = window.innerWidth,\n          screenh = window.innerHeight;\n\n    const targetw = 1280,\n          targeth = 720;\n\n    const targetScale = Math.min(screenw / targetw, screenh / targeth);\n\n    container.style.zoom = targetScale;\n  }\n\n  events.on(window, \"resize\", this.rescale, this);\n\n  slides.forEach(((slide) => this.initModules(slide)).bind(this));\n\n  events.on(container, events.vendorPrefix(\"TransitionEnd\"), this.transitionEnd, this);\n\n  this.bind = (binding, callback) => {\n    mousetrap.bind(binding, callback.bind(this));\n  };\n\n  this.bind([\"pageup\", \"left\"], this.previousItem);\n  this.bind([\"pagedown\", \"right\"], this.nextItem);\n\n  // hammer(container).on(\"dragright\", this.previousItem.bind(this));\n  // hammer(container).on(\"dragleft\", this.nextItem.bind(this));\n  // hammer(container).on(\"tap\", this.nextItem.bind(this));\n\n  setTimeout(() => {\n    this.rescale();\n\n    let match = /^#(\\d+)$/.exec(window.location.hash);\n    if (match) {\n      this.activateItem(parseInt(match[1], 10));\n    } else {\n      this.nextItem();\n    }\n  }, 1);\n\n}\n\nmodule.exports = Deck;\n\n\n\n/** WEBPACK FOOTER **\n ** ../pink/deck.es6\n **/","(typeof $__placeholder__0 === 'undefined' ?\n          'undefined' : $__placeholder__1)\n\n\n/** WEBPACK FOOTER **\n ** @traceur/generated/TemplateParser/4\n **/","$traceurRuntime.typeof($__placeholder__0)\n\n\n/** WEBPACK FOOTER **\n ** @traceur/generated/TemplateParser/3\n **/","/*global setTimeout */\n\nvar events = require(\"../lib/events\");\n\nfunction Background(slide, url) {\n\n  const preload = document.createElement(\"img\");\n  preload.src = url;\n\n  // --- activate\n\n  this.activate = () => {\n    if (this.background) this.background.parentNode.removeChild(this.background);\n    this.background = document.createElement(\"div\");\n    this.background.classList.add(\"background\");\n    this.background.style.backgroundImage = \"url(\" + url + \")\";\n    slide.parentNode.appendChild(this.background);\n    setTimeout((() => {\n      this.background.classList.add(\"active\");\n    }).bind(this), 1);\n  }\n\n  // --- cleanup\n\n  this.cleanup = () => {\n    events.once(this.background, events.vendorPrefix(\"TransitionEnd\"), () => {\n      this.background.parentNode.removeChild(this.background);\n      this.background = null;\n    }, this);\n    this.background.classList.remove(\"active\");\n  }\n\n}\n\nmodule.exports = Background;\n\n\n\n/** WEBPACK FOOTER **\n ** ../pink/modules/background.es6\n **/","function Image(slide, url) {\n\n  slide.style.backgroundImage = \"url(\" + url + \")\";\n\n}\n\nmodule.exports = Image;\n\n\n\n/** WEBPACK FOOTER **\n ** ../pink/modules/image.es6\n **/","/*global define:false */\n/**\n * Copyright 2013 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.4.6\n * @url craig.is/killing/mice\n */\n/**\n * mapping of special keycodes to their corresponding keys\n *\n * everything in this dictionary cannot use keypress events\n * so it has to be here to map to the correct keycodes for\n * keyup/keydown events\n *\n * @type {Object}\n */\nvar _MAP = {\n  8: 'backspace',\n  9: 'tab',\n  13: 'enter',\n  16: 'shift',\n  17: 'ctrl',\n  18: 'alt',\n  20: 'capslock',\n  27: 'esc',\n  32: 'space',\n  33: 'pageup',\n  34: 'pagedown',\n  35: 'end',\n  36: 'home',\n  37: 'left',\n  38: 'up',\n  39: 'right',\n  40: 'down',\n  45: 'ins',\n  46: 'del',\n  91: 'meta',\n  93: 'meta',\n  224: 'meta'\n},\n\n    /**\n     * mapping for special characters so they can support\n     *\n     * this dictionary is only used incase you want to bind a\n     * keyup or keydown event to one of these keys\n     *\n     * @type {Object}\n     */\n    _KEYCODE_MAP = {\n      106: '*',\n      107: '+',\n      109: '-',\n      110: '.',\n      111 : '/',\n      186: ';',\n      187: '=',\n      188: ',',\n      189: '-',\n      190: '.',\n      191: '/',\n      192: '`',\n      219: '[',\n      220: '\\\\',\n      221: ']',\n      222: '\\''\n    },\n\n    /**\n     * this is a mapping of keys that require shift on a US keypad\n     * back to the non shift equivelents\n     *\n     * this is so you can use keyup events with these keys\n     *\n     * note that this will only work reliably on US keyboards\n     *\n     * @type {Object}\n     */\n    _SHIFT_MAP = {\n      '~': '`',\n      '!': '1',\n      '@': '2',\n      '#': '3',\n      '$': '4',\n      '%': '5',\n      '^': '6',\n      '&': '7',\n      '*': '8',\n      '(': '9',\n      ')': '0',\n      '_': '-',\n      '+': '=',\n      ':': ';',\n      '\\\"': '\\'',\n      '<': ',',\n      '>': '.',\n      '?': '/',\n      '|': '\\\\'\n    },\n\n    /**\n     * this is a list of special strings you can use to map\n     * to modifier keys when you specify your keyboard shortcuts\n     *\n     * @type {Object}\n     */\n    _SPECIAL_ALIASES = {\n      'option': 'alt',\n      'command': 'meta',\n      'return': 'enter',\n      'escape': 'esc',\n      'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n    },\n\n    /**\n     * variable to store the flipped version of _MAP from above\n     * needed to check if we should use keypress or not when no action\n     * is specified\n     *\n     * @type {Object|undefined}\n     */\n    _REVERSE_MAP,\n\n    /**\n     * a list of all the callbacks setup via Mousetrap.bind()\n     *\n     * @type {Object}\n     */\n    _callbacks = {},\n\n    /**\n     * direct map of string combinations to callbacks used for trigger()\n     *\n     * @type {Object}\n     */\n    _directMap = {},\n\n    /**\n     * keeps track of what level each sequence is at since multiple\n     * sequences can start out with the same sequence\n     *\n     * @type {Object}\n     */\n    _sequenceLevels = {},\n\n    /**\n     * variable to store the setTimeout call\n     *\n     * @type {null|number}\n     */\n    _resetTimer,\n\n    /**\n     * temporary state where we will ignore the next keyup\n     *\n     * @type {boolean|string}\n     */\n    _ignoreNextKeyup = false,\n\n    /**\n     * temporary state where we will ignore the next keypress\n     *\n     * @type {boolean}\n     */\n    _ignoreNextKeypress = false,\n\n    /**\n     * are we currently inside of a sequence?\n     * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n     *\n     * @type {boolean|string}\n     */\n    _nextExpectedAction = false;\n\n/**\n * loop through the f keys, f1 to f19 and add them to the map\n * programatically\n */\nfor (var i = 1; i < 20; ++i) {\n  _MAP[111 + i] = 'f' + i;\n}\n\n/**\n * loop through to map numbers on the numeric keypad\n */\nfor (i = 0; i <= 9; ++i) {\n  _MAP[i + 96] = i;\n}\n\n/**\n * cross browser add event method\n *\n * @param {Element|HTMLDocument} object\n * @param {string} type\n * @param {Function} callback\n * @returns void\n */\nfunction _addEvent(object, type, callback) {\n  if (object.addEventListener) {\n    object.addEventListener(type, callback, false);\n    return;\n  }\n\n  object.attachEvent('on' + type, callback);\n}\n\n/**\n * takes the event and returns the key character\n *\n * @param {Event} e\n * @return {string}\n */\nfunction _characterFromEvent(e) {\n\n  // for keypress events we should return the character as is\n  if (e.type == 'keypress') {\n    var character = String.fromCharCode(e.which);\n\n    // if the shift key is not pressed then it is safe to assume\n    // that we want the character to be lowercase.  this means if\n    // you accidentally have caps lock on then your key bindings\n    // will continue to work\n    //\n    // the only side effect that might not be desired is if you\n    // bind something like 'A' cause you want to trigger an\n    // event when capital A is pressed caps lock will no longer\n    // trigger the event.  shift+a will though.\n    if (!e.shiftKey) {\n      character = character.toLowerCase();\n    }\n\n    return character;\n  }\n\n  // for non keypress events the special maps are needed\n  if (_MAP[e.which]) {\n    return _MAP[e.which];\n  }\n\n  if (_KEYCODE_MAP[e.which]) {\n    return _KEYCODE_MAP[e.which];\n  }\n\n  // if it is not in the special map\n\n  // with keydown and keyup events the character seems to always\n  // come in as an uppercase character whether you are pressing shift\n  // or not.  we should make sure it is always lowercase for comparisons\n  return String.fromCharCode(e.which).toLowerCase();\n}\n\n/**\n * checks if two arrays are equal\n *\n * @param {Array} modifiers1\n * @param {Array} modifiers2\n * @returns {boolean}\n */\nfunction _modifiersMatch(modifiers1, modifiers2) {\n  return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n}\n\n/**\n * resets all sequence counters except for the ones passed in\n *\n * @param {Object} doNotReset\n * @returns void\n */\nfunction _resetSequences(doNotReset) {\n  doNotReset = doNotReset || {};\n\n  var activeSequences = false,\n      key;\n\n  for (key in _sequenceLevels) {\n    if (doNotReset[key]) {\n      activeSequences = true;\n      continue;\n    }\n    _sequenceLevels[key] = 0;\n  }\n\n  if (!activeSequences) {\n    _nextExpectedAction = false;\n  }\n}\n\n/**\n * finds all callbacks that match based on the keycode, modifiers,\n * and action\n *\n * @param {string} character\n * @param {Array} modifiers\n * @param {Event|Object} e\n * @param {string=} sequenceName - name of the sequence we are looking for\n * @param {string=} combination\n * @param {number=} level\n * @returns {Array}\n */\nfunction _getMatches(character, modifiers, e, sequenceName, combination, level) {\n  var i,\n      callback,\n      matches = [],\n      action = e.type;\n\n  // if there are no events related to this keycode\n  if (!_callbacks[character]) {\n    return [];\n  }\n\n  // if a modifier key is coming up on its own we should allow it\n  if (action == 'keyup' && _isModifier(character)) {\n    modifiers = [character];\n  }\n\n  // loop through all callbacks for the key that was pressed\n  // and see if any of them match\n  for (i = 0; i < _callbacks[character].length; ++i) {\n    callback = _callbacks[character][i];\n\n    // if a sequence name is not specified, but this is a sequence at\n    // the wrong level then move onto the next match\n    if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n      continue;\n    }\n\n    // if the action we are looking for doesn't match the action we got\n    // then we should keep going\n    if (action != callback.action) {\n      continue;\n    }\n\n    // if this is a keypress event and the meta key and control key\n    // are not pressed that means that we need to only look at the\n    // character, otherwise check the modifiers as well\n    //\n    // chrome will not fire a keypress if meta or control is down\n    // safari will fire a keypress if meta or meta+shift is down\n    // firefox will fire a keypress if meta or control is down\n    if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\n      // when you bind a combination or sequence a second time it\n      // should overwrite the first one.  if a sequenceName or\n      // combination is specified in this call it does just that\n      //\n      // @todo make deleting its own method?\n      var deleteCombo = !sequenceName && callback.combo == combination;\n      var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n      if (deleteCombo || deleteSequence) {\n        _callbacks[character].splice(i, 1);\n      }\n\n      matches.push(callback);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * takes a key event and figures out what the modifiers are\n *\n * @param {Event} e\n * @returns {Array}\n */\nfunction _eventModifiers(e) {\n  var modifiers = [];\n\n  if (e.shiftKey) {\n    modifiers.push('shift');\n  }\n\n  if (e.altKey) {\n    modifiers.push('alt');\n  }\n\n  if (e.ctrlKey) {\n    modifiers.push('ctrl');\n  }\n\n  if (e.metaKey) {\n    modifiers.push('meta');\n  }\n\n  return modifiers;\n}\n\n/**\n * prevents default for this event\n *\n * @param {Event} e\n * @returns void\n */\nfunction _preventDefault(e) {\n  if (e.preventDefault) {\n    e.preventDefault();\n    return;\n  }\n\n  e.returnValue = false;\n}\n\n/**\n * stops propogation for this event\n *\n * @param {Event} e\n * @returns void\n */\nfunction _stopPropagation(e) {\n  if (e.stopPropagation) {\n    e.stopPropagation();\n    return;\n  }\n\n  e.cancelBubble = true;\n}\n\n/**\n * actually calls the callback function\n *\n * if your callback function returns false this will use the jquery\n * convention - prevent default and stop propogation on the event\n *\n * @param {Function} callback\n * @param {Event} e\n * @returns void\n */\nfunction _fireCallback(callback, e, combo, sequence) {\n\n  // if this event should not happen stop here\n  if (Mousetrap.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n    return;\n  }\n\n  if (callback(e, combo) === false) {\n    _preventDefault(e);\n    _stopPropagation(e);\n  }\n}\n\n/**\n * handles a character key event\n *\n * @param {string} character\n * @param {Array} modifiers\n * @param {Event} e\n * @returns void\n */\nfunction _handleKey(character, modifiers, e) {\n  var callbacks = _getMatches(character, modifiers, e),\n      i,\n      doNotReset = {},\n      maxLevel = 0,\n      processedSequenceCallback = false;\n\n  // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n  for (i = 0; i < callbacks.length; ++i) {\n    if (callbacks[i].seq) {\n      maxLevel = Math.max(maxLevel, callbacks[i].level);\n    }\n  }\n\n  // loop through matching callbacks for this key event\n  for (i = 0; i < callbacks.length; ++i) {\n\n    // fire for all sequence callbacks\n    // this is because if for example you have multiple sequences\n    // bound such as \"g i\" and \"g t\" they both need to fire the\n    // callback for matching g cause otherwise you can only ever\n    // match the first one\n    if (callbacks[i].seq) {\n\n      // only fire callbacks for the maxLevel to prevent\n      // subsequences from also firing\n      //\n      // for example 'a option b' should not cause 'option b' to fire\n      // even though 'option b' is part of the other sequence\n      //\n      // any sequences that do not match here will be discarded\n      // below by the _resetSequences call\n      if (callbacks[i].level != maxLevel) {\n        continue;\n      }\n\n      processedSequenceCallback = true;\n\n      // keep a list of which sequences were matches for later\n      doNotReset[callbacks[i].seq] = 1;\n      _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n      continue;\n    }\n\n    // if there were no sequence matches but we are still here\n    // that means this is a regular match so we should fire that\n    if (!processedSequenceCallback) {\n      _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n    }\n  }\n\n  // if the key you pressed matches the type of sequence without\n  // being a modifier (ie \"keyup\" or \"keypress\") then we should\n  // reset all sequences that were not matched by this event\n  //\n  // this is so, for example, if you have the sequence \"h a t\" and you\n  // type \"h e a r t\" it does not match.  in this case the \"e\" will\n  // cause the sequence to reset\n  //\n  // modifier keys are ignored because you can have a sequence\n  // that contains modifiers such as \"enter ctrl+space\" and in most\n  // cases the modifier key will be pressed before the next key\n  //\n  // also if you have a sequence such as \"ctrl+b a\" then pressing the\n  // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n  //\n  // the \"keydown\" is expected when there is a modifier, but the\n  // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n  // after and that causes the sequence to reset\n  //\n  // we ignore keypresses in a sequence that directly follow a keydown\n  // for the same character\n  var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n  if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n    _resetSequences(doNotReset);\n  }\n\n  _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n}\n\n/**\n * handles a keydown event\n *\n * @param {Event} e\n * @returns void\n */\nfunction _handleKeyEvent(e) {\n\n  // normalize e.which for key events\n  // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n  if (typeof e.which !== 'number') {\n    e.which = e.keyCode;\n  }\n\n  var character = _characterFromEvent(e);\n\n  // no character found then stop\n  if (!character) {\n    return;\n  }\n\n  // need to use === for the character check because the character can be 0\n  if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n    _ignoreNextKeyup = false;\n    return;\n  }\n\n  Mousetrap.handleKey(character, _eventModifiers(e), e);\n}\n\n/**\n * determines if the keycode specified is a modifier key or not\n *\n * @param {string} key\n * @returns {boolean}\n */\nfunction _isModifier(key) {\n  return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n}\n\n/**\n * called to set a 1 second timeout on the specified sequence\n *\n * this is so after each key press in the sequence you have 1 second\n * to press the next key before you have to start over\n *\n * @returns void\n */\nfunction _resetSequenceTimer() {\n  clearTimeout(_resetTimer);\n  _resetTimer = setTimeout(_resetSequences, 1000);\n}\n\n/**\n * reverses the map lookup so that we can look for specific keys\n * to see what can and can't use keypress\n *\n * @return {Object}\n */\nfunction _getReverseMap() {\n  if (!_REVERSE_MAP) {\n    _REVERSE_MAP = {};\n    for (var key in _MAP) {\n\n      // pull out the numeric keypad from here cause keypress should\n      // be able to detect the keys from the character\n      if (key > 95 && key < 112) {\n        continue;\n      }\n\n      if (_MAP.hasOwnProperty(key)) {\n        _REVERSE_MAP[_MAP[key]] = key;\n      }\n    }\n  }\n  return _REVERSE_MAP;\n}\n\n/**\n * picks the best action based on the key combination\n *\n * @param {string} key - character for key\n * @param {Array} modifiers\n * @param {string=} action passed in\n */\nfunction _pickBestAction(key, modifiers, action) {\n\n  // if no action was picked in we should try to pick the one\n  // that we think would work best for this key\n  if (!action) {\n    action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n  }\n\n  // modifier keys don't work as expected with keypress,\n  // switch to keydown\n  if (action == 'keypress' && modifiers.length) {\n    action = 'keydown';\n  }\n\n  return action;\n}\n\n/**\n * binds a key sequence to an event\n *\n * @param {string} combo - combo specified in bind call\n * @param {Array} keys\n * @param {Function} callback\n * @param {string=} action\n * @returns void\n */\nfunction _bindSequence(combo, keys, callback, action) {\n\n  // start off by adding a sequence level record for this combination\n  // and setting the level to 0\n  _sequenceLevels[combo] = 0;\n\n  /**\n   * callback to increase the sequence level for this sequence and reset\n   * all other sequences that were active\n   *\n   * @param {string} nextAction\n   * @returns {Function}\n   */\n  function _increaseSequence(nextAction) {\n    return function() {\n      _nextExpectedAction = nextAction;\n      ++_sequenceLevels[combo];\n      _resetSequenceTimer();\n    };\n  }\n\n  /**\n   * wraps the specified callback inside of another function in order\n   * to reset all sequence counters as soon as this sequence is done\n   *\n   * @param {Event} e\n   * @returns void\n   */\n  function _callbackAndReset(e) {\n    _fireCallback(callback, e, combo);\n\n    // we should ignore the next key up if the action is key down\n    // or keypress.  this is so if you finish a sequence and\n    // release the key the final key will not trigger a keyup\n    if (action !== 'keyup') {\n      _ignoreNextKeyup = _characterFromEvent(e);\n    }\n\n    // weird race condition if a sequence ends with the key\n    // another sequence begins with\n    setTimeout(_resetSequences, 10);\n  }\n\n  // loop through keys one at a time and bind the appropriate callback\n  // function.  for any key leading up to the final one it should\n  // increase the sequence. after the final, it should reset all sequences\n  //\n  // if an action is specified in the original bind call then that will\n  // be used throughout.  otherwise we will pass the action that the\n  // next key in the sequence should match.  this allows a sequence\n  // to mix and match keypress and keydown events depending on which\n  // ones are better suited to the key provided\n  for (var i = 0; i < keys.length; ++i) {\n    var isFinal = i + 1 === keys.length;\n    var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n    _bindSingle(keys[i], wrappedCallback, action, combo, i);\n  }\n}\n\n/**\n * Converts from a string key combination to an array\n *\n * @param  {string} combination like \"command+shift+l\"\n * @return {Array}\n */\nfunction _keysFromString(combination) {\n  if (combination === '+') {\n    return ['+'];\n  }\n\n  return combination.split('+');\n}\n\n/**\n * Gets info for a specific key combination\n *\n * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n * @param  {string=} action\n * @returns {Object}\n */\nfunction _getKeyInfo(combination, action) {\n  var keys,\n      key,\n      i,\n      modifiers = [];\n\n  // take the keys from this pattern and figure out what the actual\n  // pattern is all about\n  keys = _keysFromString(combination);\n\n  for (i = 0; i < keys.length; ++i) {\n    key = keys[i];\n\n    // normalize key names\n    if (_SPECIAL_ALIASES[key]) {\n      key = _SPECIAL_ALIASES[key];\n    }\n\n    // if this is not a keypress event then we should\n    // be smart about using shift keys\n    // this will only work for US keyboards however\n    if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n      key = _SHIFT_MAP[key];\n      modifiers.push('shift');\n    }\n\n    // if this key is a modifier then add it to the list of modifiers\n    if (_isModifier(key)) {\n      modifiers.push(key);\n    }\n  }\n\n  // depending on what the key combination is\n  // we will try to pick the best event for it\n  action = _pickBestAction(key, modifiers, action);\n\n  return {\n    key: key,\n    modifiers: modifiers,\n    action: action\n  };\n}\n\n/**\n * binds a single keyboard combination\n *\n * @param {string} combination\n * @param {Function} callback\n * @param {string=} action\n * @param {string=} sequenceName - name of sequence if part of sequence\n * @param {number=} level - what part of the sequence the command is\n * @returns void\n */\nfunction _bindSingle(combination, callback, action, sequenceName, level) {\n\n  // store a direct mapped reference for use with Mousetrap.trigger\n  _directMap[combination + ':' + action] = callback;\n\n  // make sure multiple spaces in a row become a single space\n  combination = combination.replace(/\\s+/g, ' ');\n\n  var sequence = combination.split(' '),\n      info;\n\n  // if this pattern is a sequence of keys then run through this method\n  // to reprocess each pattern one key at a time\n  if (sequence.length > 1) {\n    _bindSequence(combination, sequence, callback, action);\n    return;\n  }\n\n  info = _getKeyInfo(combination, action);\n\n  // make sure to initialize array if this is the first time\n  // a callback is added for this key\n  _callbacks[info.key] = _callbacks[info.key] || [];\n\n  // remove an existing match if there is one\n  _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\n  // add this call back to the array\n  // if it is a sequence put it at the beginning\n  // if not put it at the end\n  //\n  // this is important because the way these are processed expects\n  // the sequence ones to come first\n  _callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n    callback: callback,\n    modifiers: info.modifiers,\n    action: info.action,\n    seq: sequenceName,\n    level: level,\n    combo: combination\n  });\n}\n\n/**\n * binds multiple combinations to the same callback\n *\n * @param {Array} combinations\n * @param {Function} callback\n * @param {string|undefined} action\n * @returns void\n */\nfunction _bindMultiple(combinations, callback, action) {\n  for (var i = 0; i < combinations.length; ++i) {\n    _bindSingle(combinations[i], callback, action);\n  }\n}\n\n// start!\n_addEvent(document, 'keypress', _handleKeyEvent);\n_addEvent(document, 'keydown', _handleKeyEvent);\n_addEvent(document, 'keyup', _handleKeyEvent);\n\nvar Mousetrap = {\n\n  /**\n   * binds an event to mousetrap\n   *\n   * can be a single key, a combination of keys separated with +,\n   * an array of keys, or a sequence of keys separated by spaces\n   *\n   * be sure to list the modifier keys first to make sure that the\n   * correct key ends up getting bound (the last key in the pattern)\n   *\n   * @param {string|Array} keys\n   * @param {Function} callback\n   * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n   * @returns void\n   */\n  bind: function(keys, callback, action) {\n    keys = keys instanceof Array ? keys : [keys];\n    _bindMultiple(keys, callback, action);\n    return this;\n  },\n\n  /**\n   * unbinds an event to mousetrap\n   *\n   * the unbinding sets the callback function of the specified key combo\n   * to an empty function and deletes the corresponding key in the\n   * _directMap dict.\n   *\n   * TODO: actually remove this from the _callbacks dictionary instead\n   * of binding an empty function\n   *\n   * the keycombo+action has to be exactly the same as\n   * it was defined in the bind method\n   *\n   * @param {string|Array} keys\n   * @param {string} action\n   * @returns void\n   */\n  unbind: function(keys, action) {\n    return Mousetrap.bind(keys, function() {}, action);\n  },\n\n  /**\n   * triggers an event that has already been bound\n   *\n   * @param {string} keys\n   * @param {string=} action\n   * @returns void\n   */\n  trigger: function(keys, action) {\n    if (_directMap[keys + ':' + action]) {\n      _directMap[keys + ':' + action]({}, keys);\n    }\n    return this;\n  },\n\n  /**\n   * resets the library back to its initial state.  this is useful\n   * if you want to clear out the current keyboard shortcuts and bind\n   * new ones - for example if you switch to another page\n   *\n   * @returns void\n   */\n  reset: function() {\n    _callbacks = {};\n    _directMap = {};\n    return this;\n  },\n\n  /**\n   * should we stop this event before firing off callbacks\n   *\n   * @param {Event} e\n   * @param {Element} element\n   * @return {boolean}\n   */\n  stopCallback: function(e, element) {\n\n    // if the element has the class \"mousetrap\" then no need to stop\n    if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n      return false;\n    }\n\n    // stop for input, select, and textarea\n    return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n  },\n\n  /**\n   * exposes _handleKey publicly so it can be overwritten by extensions\n   */\n  handleKey: _handleKey\n};\n\nmodule.exports = Mousetrap;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../pink/lib/mousetrap.js\n ** module id = 5\n ** module chunks = 0\n **/","var toArray = module.exports.toArray = function toArray(indexable) {\n  var i, out = [], l = indexable.length;\n  for (i = 0; i < l; i++) {\n    out.push(indexable[i]);\n  }\n  return out;\n}\n\nmodule.exports.flatMap = function flatMap(f, seq) {\n  var i, out = [], l = seq.length;\n  for (i = 0; i < l; i++) {\n    out = out.concat(f(seq[i]));\n  }\n  return out;\n}\n\nfunction copyProps(target, src) {\n  var prop;\n  for (prop in src) {\n    if (src.hasOwnProperty(prop)) {\n      target[prop] = src[prop];\n    }\n  }\n  return target;\n}\n\nmodule.exports.merge = function merge(obj1) {\n  return toArray(arguments).slice(1).reduce(function(acc, next) {\n    return copyProps(acc, next);\n  }, copyProps({}, obj1));\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../pink/lib/seq.js\n ** module id = 6\n ** module chunks = 0\n **/","@font-face {\n  font-family: 'Helvetica Neue LT Std';\n  font-style: normal;\n  font-weight: 400;\n  src: local('Helvetica Neue LT Std Regular'), url(HelveticaNeueLTStd-Md.otf) format('opentype');\n}\n@font-face {\n  font-family: 'Helvetica Neue LT Std';\n  font-style: normal;\n  font-weight: 700;\n  src: local('Helvetica Neue LT Std Bold'), url(HelveticaNeueLTStd-Bd.otf) format('opentype');\n}\n@font-face {\n  font-family: 'Helvetica Neue LT Std';\n  font-style: italic;\n  font-weight: 400;\n  src: local('Helvetica Neue LT Std Regular Italic'), url(HelveticaNeueLTStd-MdIt.otf) format('opentype');\n}\n@font-face {\n  font-family: 'Helvetica Neue LT Std';\n  font-style: italic;\n  font-weight: 700;\n  src: local('Helvetica Neue LT Std Bold Italic'), url(HelveticaNeueLTStd-BdIt.otf) format('opentype');\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../pink/css/fonts/Helvetica/helvetica.css\n **/","@font-face {\n  font-family: 'Inconsolata';\n  font-style: normal;\n  font-weight: 400;\n  src: local('Inconsolata'), url(Inconsolata-Regular.ttf) format('truetype');\n}\n@font-face {\n  font-family: 'Inconsolata';\n  font-style: normal;\n  font-weight: 700;\n  src: local('Inconsolata Bold'), local('Inconsolata-Bold'), url(Inconsolata-Bold.ttf) format('truetype');\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ../pink/css/fonts/Inconsolata/inconsolata.css\n **/","@import \"fonts/Helvetica/helvetica.css\";@import \"fonts/Inconsolata/inconsolata.css\";html,body{border:0;font-family:\"Helvetica-Neue\",\"Helvetica\",Arial,sans-serif;line-height:1.5;margin:0;padding:0}div,span,object,iframe,img,table,caption,thead,tbody,tfoot,tr,tr,td,article,aside,canvas,details,figure,hgroup,menu,nav,footer,header,section,summary,mark,audio,video{border:0;margin:0;padding:0}h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,address,cit,code,del,dfn,em,ins,q,samp,small,strong,sub,sup,b,i,hr,dl,dt,dd,ol,ul,li,fieldset,legend,label{border:0;font-size:100%;vertical-align:baseline;margin:0;padding:0}article,aside,canvas,figure,figure img,figcaption,hgroup,footer,header,nav,section,audio,video{display:block}table{border-collapse:separate;border-spacing:0}table caption,table th,table td{text-align:left;vertical-align:middle}a img{border:0}:focus{outline:0}*,*:before,*:after{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}body{color:#222;margin:0;padding:0;border:0;font-family:\"Helvetica Neue LT Std\";font-size:48pt;line-height:1.2em;visibility:visible}p,a,li,li:before,h1,h2,h3,h4,h5,h6{text-shadow:0 0 .1em rgba(0,0,0,0.5)}h1,h2,h3,h4,h5,h6{text-align:center;font-weight:bold;background-color:rgba(0,0,0,0.1);margin:.4em -100%}h1{font-size:1.6em;padding-top:.25em}h2{font-size:1.4em;padding-top:.3em}h3{font-size:1.2em;padding-top:.3em}h4,h5,h6{font-size:1.1em;padding-top:.3em}strong{letter-spacing:.05em}a{color:#000}em{font-style:normal;text-decoration:underline}.attribution{font-size:.9em}#slides{z-index:1;position:fixed;background:#ccc}#slides,#slides .background{background-size:cover;background-position:50% 50%;width:100%;height:100%;margin:0;padding:0;border:0}#slides .background{z-index:2;position:absolute;opacity:0;-webkit-transition:opacity .3s ease;-moz-transition:opacity .3s ease;transition:opacity .3s ease}#slides .background.active{opacity:1}#slides section{background-color:rgba(255,255,255,0.8);background-size:cover;background-position:50% 50%;z-index:10;visibility:hidden;position:absolute;width:80%;height:80%;left:10%;top:10%;margin:0;padding:0 10%;border:0;border-radius:.2em;display:-webkit-box;display:-moz-box;display:box;-webkit-box-pack:center;-webkit-box-align:center;-moz-box-pack:center;-moz-box-align:center;box-pack:center;box-align:center;opacity:0;-webkit-transform:scale(1.25);-webkit-filter:grayscale(100%);-webkit-transition:-webkit-filter .3s ease,-webkit-transform .3s ease,opacity .3s ease;-moz-transform:scale(1.25);-moz-filter:grayscale(100%);-moz-transition:-moz-filter .3s ease,-moz-transform .3s ease,opacity .3s ease;transform:scale(1.25);filter:grayscale(100%);transition:filter .3s ease,transform .3s ease,opacity .3s ease}#slides section .slideContainer{width:100%}#slides section.current,#slides section.out{visibility:visible}#slides section.current{opacity:1;-webkit-filter:grayscale(0);-webkit-transform:scale(1);-moz-filter:grayscale(0);-moz-transform:scale(1);filter:grayscale(0);transform:scale(1)}#slides section.out{-webkit-transform:scale(.75);-moz-transform:scale(.75);transform:scale(.75)}#slides section .fragment{opacity:0;-webkit-transform:scale(1.25);-webkit-filter:grayscale(100%);-webkit-transition:-webkit-filter .3s ease,-webkit-transform .3s ease,opacity .3s ease;-moz-transform:scale(1.25);-moz-filter:grayscale(100%);-moz-transition:-moz-filter .3s ease,-moz-transform .3s ease,opacity .3s ease;transform:scale(1.25);filter:grayscale(100%);transition:filter .3s ease,transform .3s ease,opacity .3s ease}#slides section .fragment.active{opacity:1;-webkit-transform:scale(1);-webkit-filter:grayscale(0);-moz-transform:scale(1);-moz-filter:grayscale(0);transform:scale(1);filter:grayscale(0)}#slides section.editor{left:0;top:0;width:100%;height:100%;border-radius:0;background:none}#slides section.editor .editorFrame,#slides section.editor .targetFrame{position:absolute;height:100%;top:0;padding:.5em}#slides section.editor .editorFrame{left:0;width:100%}#slides section.editor.withTargetFrame .editorFrame,#slides section.editor.withTargetFrame .targetFrame{width:50%}#slides section.editor.withTargetFrame .editorFrame{padding-right:0}#slides section.editor.withTargetFrame .targetFrame{left:50%}#slides section.editor .targetFrame iframe{z-index:14;background-color:#444;background-image:url(doge.svg);background-size:contain;background-repeat:no-repeat;background-position:50% 50%;width:100%;height:100%;margin:0;padding:0}#slides section.editor .loaderFrame{z-index:15;background:#444;width:100%;height:100%;margin:0;padding:0}#slides section.editor .CodeMirror{font-family:\"Inconsolata\";line-height:1.2em;font-size:.4em}#slides section.editor .CodeMirror,#slides section.editor .loaderFrame,#slides section.editor .targetFrame iframe{box-shadow:0 .1em .2em rgba(0,0,0,0.6);border-radius:.1em}#slides section.photo{background-size:contain;background-color:rgba(0,0,0,0);background-repeat:no-repeat}#slides section.white{text-align:center}#slides section.white h1,#slides section.white h2,#slides section.white h3,#slides section.white h4,#slides section.white h5,#slides section.white h6,#slides section.white p,#slides section.white a,#slides section.white li{color:#fff;text-shadow:0 -0.05em .1em #000,0 .05em .1em #000,0 .1em .3em #000;background:none;font-weight:normal}#slides section.align-bottom{-webkit-box-pack:end;-webkit-box-align:end;-moz-box-pack:end;-moz-box-align:end;box-pack:end;box-align:end;padding-bottom:.5em}#slides section.erlang-the-movie h1,#slides section.erlang-the-movie h2,#slides section.erlang-the-movie h3,#slides section.erlang-the-movie h4,#slides section.erlang-the-movie h5,#slides section.erlang-the-movie h6,#slides section.erlang-the-movie p,#slides section.erlang-the-movie a{font-weight:bolder;-webkit-transform:scale(.8, 1);-moz-transform:scale(.8, 1);transform:scale(.8, 1);margin:0}#slides section.erlang-the-movie p{font-size:.9em;margin:0 -6em}.CodeMirror-hints,.CodeMirror-Tern-tooltip{font-family:\"Inconsolata\";line-height:1.2em;font-size:.5em !important;text-shadow:none}.CodeMirror-hints li,.CodeMirror-Tern-tooltip li{text-shadow:none}.cm-errors{width:1em}.CodeMirror-gutter-wrapper .cm-error{width:1em;height:1em;background:url(red-doge.svg);background-size:contain}\n\n\n/** WEBPACK FOOTER **\n ** ../pink/~/less-loader!../pink/css/screen.less\n **/","/*! Hammer.JS - v1.0.11 - 2014-05-20\n * http://eightmedia.github.io/hammer.js\n *\n * Copyright (c) 2014 Jorik Tangelder <j.tangelder@gmail.com>;\n * Licensed under the MIT license */\n\n(function(window, undefined) {\n  'use strict';\n\n/**\n * Hammer\n * use this to create instances\n * @param   {HTMLElement}   element\n * @param   {Object}        options\n * @returns {Hammer.Instance}\n * @constructor\n */\nvar Hammer = function(element, options) {\n  return new Hammer.Instance(element, options || {});\n};\n\nHammer.VERSION = '1.0.11';\n\n// default settings\nHammer.defaults = {\n  // add styles and attributes to the element to prevent the browser from doing\n  // its native behavior. this doesnt prevent the scrolling, but cancels\n  // the contextmenu, tap highlighting etc\n  // set to false to disable this\n  stop_browser_behavior: {\n    // this also triggers onselectstart=false for IE\n    userSelect       : 'none',\n    // this makes the element blocking in IE10> and Chrome 35>, you could experiment with the value\n    // see for more options the wiki: https://github.com/EightMedia/hammer.js/wiki\n    touchAction      : 'pan-y',\n\n    touchCallout     : 'none',\n    contentZooming   : 'none',\n    userDrag         : 'none',\n    tapHighlightColor: 'rgba(0,0,0,0)'\n  }\n\n  //\n  // more settings are defined per gesture at /gestures\n  //\n};\n\n\n// detect touchevents\nHammer.HAS_POINTEREVENTS = window.navigator.pointerEnabled || window.navigator.msPointerEnabled;\nHammer.HAS_TOUCHEVENTS = ('ontouchstart' in window);\n\n// dont use mouseevents on mobile devices\nHammer.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android|silk/i;\nHammer.NO_MOUSEEVENTS = Hammer.HAS_TOUCHEVENTS && window.navigator.userAgent.match(Hammer.MOBILE_REGEX);\n\n// eventtypes per touchevent (start, move, end)\n// are filled by Event.determineEventTypes on setup\nHammer.EVENT_TYPES = {};\n\n// interval in which Hammer recalculates current velocity in ms\nHammer.UPDATE_VELOCITY_INTERVAL = 16;\n\n// hammer document where the base events are added at\nHammer.DOCUMENT = window.document;\n\n// define these also as vars, for better minification\n// direction defines\nvar DIRECTION_DOWN = Hammer.DIRECTION_DOWN = 'down';\nvar DIRECTION_LEFT = Hammer.DIRECTION_LEFT = 'left';\nvar DIRECTION_UP = Hammer.DIRECTION_UP = 'up';\nvar DIRECTION_RIGHT = Hammer.DIRECTION_RIGHT = 'right';\n\n// pointer type\nvar POINTER_MOUSE = Hammer.POINTER_MOUSE = 'mouse';\nvar POINTER_TOUCH = Hammer.POINTER_TOUCH = 'touch';\nvar POINTER_PEN = Hammer.POINTER_PEN = 'pen';\n\n// touch event defines\nvar EVENT_START = Hammer.EVENT_START = 'start';\nvar EVENT_MOVE = Hammer.EVENT_MOVE = 'move';\nvar EVENT_END = Hammer.EVENT_END = 'end';\n\n\n// plugins and gestures namespaces\nHammer.plugins = Hammer.plugins || {};\nHammer.gestures = Hammer.gestures || {};\n\n\n// if the window events are set...\nHammer.READY = false;\n\n\n/**\n * setup events to detect gestures on the document\n */\nfunction setup() {\n  if(Hammer.READY) {\n    return;\n  }\n\n  // find what eventtypes we add listeners to\n  Event.determineEventTypes();\n\n  // Register all gestures inside Hammer.gestures\n  Utils.each(Hammer.gestures, function(gesture){\n    Detection.register(gesture);\n  });\n\n  // Add touch events on the document\n  Event.onTouch(Hammer.DOCUMENT, EVENT_MOVE, Detection.detect);\n  Event.onTouch(Hammer.DOCUMENT, EVENT_END, Detection.detect);\n\n  // Hammer is ready...!\n  Hammer.READY = true;\n}\n\n\nvar Utils = Hammer.utils = {\n  /**\n   * extend method,\n   * also used for cloning when dest is an empty object\n   * @param   {Object}    dest\n   * @param   {Object}    src\n   * @parm  {Boolean}  merge    do a merge\n   * @returns {Object}    dest\n   */\n  extend: function extend(dest, src, merge) {\n    for(var key in src) {\n      if(dest[key] !== undefined && merge) {\n        continue;\n      }\n      dest[key] = src[key];\n    }\n    return dest;\n  },\n\n\n  /**\n   * for each\n   * @param obj\n   * @param iterator\n   */\n  each: function each(obj, iterator, context) {\n    var i, o;\n    // native forEach on arrays\n    if ('forEach' in obj) {\n      obj.forEach(iterator, context);\n    }\n    // arrays\n    else if(obj.length !== undefined) {\n      for(i=-1; (o=obj[++i]);) {\n        if (iterator.call(context, o, i, obj) === false) {\n          return;\n        }\n      }\n    }\n    // objects\n    else {\n      for(i in obj) {\n        if(obj.hasOwnProperty(i) &&\n            iterator.call(context, obj[i], i, obj) === false) {\n          return;\n        }\n      }\n    }\n  },\n\n\n  /**\n   * find if a string contains the needle\n   * @param   {String}  src\n   * @param   {String}  needle\n   * @returns {Boolean} found\n   */\n  inStr: function inStr(src, needle) {\n    return src.indexOf(needle) > -1;\n  },\n\n\n  /**\n   * find if a node is in the given parent\n   * used for event delegation tricks\n   * @param   {HTMLElement}   node\n   * @param   {HTMLElement}   parent\n   * @returns {boolean}       has_parent\n   */\n  hasParent: function hasParent(node, parent) {\n    while(node) {\n      if(node == parent) {\n        return true;\n      }\n      node = node.parentNode;\n    }\n    return false;\n  },\n\n\n  /**\n   * get the center of all the touches\n   * @param   {Array}     touches\n   * @returns {Object}    center pageXY clientXY\n   */\n  getCenter: function getCenter(touches) {\n    var pageX = []\n      , pageY = []\n      , clientX = []\n      , clientY = []\n      , min = Math.min\n      , max = Math.max;\n\n    // no need to loop when only one touch\n    if(touches.length === 1) {\n      return {\n        pageX: touches[0].pageX,\n        pageY: touches[0].pageY,\n        clientX: touches[0].clientX,\n        clientY: touches[0].clientY\n      };\n    }\n\n    Utils.each(touches, function(touch) {\n      pageX.push(touch.pageX);\n      pageY.push(touch.pageY);\n      clientX.push(touch.clientX);\n      clientY.push(touch.clientY);\n    });\n\n    return {\n      pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,\n      pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,\n      clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,\n      clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2\n    };\n  },\n\n\n  /**\n   * calculate the velocity between two points\n   * @param   {Number}    delta_time\n   * @param   {Number}    delta_x\n   * @param   {Number}    delta_y\n   * @returns {Object}    velocity\n   */\n  getVelocity: function getVelocity(delta_time, delta_x, delta_y) {\n    return {\n      x: Math.abs(delta_x / delta_time) || 0,\n      y: Math.abs(delta_y / delta_time) || 0\n    };\n  },\n\n\n  /**\n   * calculate the angle between two coordinates\n   * @param   {Touch}     touch1\n   * @param   {Touch}     touch2\n   * @returns {Number}    angle\n   */\n  getAngle: function getAngle(touch1, touch2) {\n    var x = touch2.clientX - touch1.clientX\n      , y = touch2.clientY - touch1.clientY;\n    return Math.atan2(y, x) * 180 / Math.PI;\n  },\n\n\n  /**\n   * angle to direction define\n   * @param   {Touch}     touch1\n   * @param   {Touch}     touch2\n   * @returns {String}    direction constant, like DIRECTION_LEFT\n   */\n  getDirection: function getDirection(touch1, touch2) {\n    var x = Math.abs(touch1.clientX - touch2.clientX)\n      , y = Math.abs(touch1.clientY - touch2.clientY);\n    if(x >= y) {\n      return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n    return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  },\n\n\n  /**\n   * calculate the distance between two touches\n   * @param   {Touch}     touch1\n   * @param   {Touch}     touch2\n   * @returns {Number}    distance\n   */\n  getDistance: function getDistance(touch1, touch2) {\n    var x = touch2.clientX - touch1.clientX\n      , y = touch2.clientY - touch1.clientY;\n    return Math.sqrt((x * x) + (y * y));\n  },\n\n\n  /**\n   * calculate the scale factor between two touchLists (fingers)\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param   {Array}     start\n   * @param   {Array}     end\n   * @returns {Number}    scale\n   */\n  getScale: function getScale(start, end) {\n    // need two fingers...\n    if(start.length >= 2 && end.length >= 2) {\n      return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);\n    }\n    return 1;\n  },\n\n\n  /**\n   * calculate the rotation degrees between two touchLists (fingers)\n   * @param   {Array}     start\n   * @param   {Array}     end\n   * @returns {Number}    rotation\n   */\n  getRotation: function getRotation(start, end) {\n    // need two fingers\n    if(start.length >= 2 && end.length >= 2) {\n      return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);\n    }\n    return 0;\n  },\n\n\n  /**\n   * boolean if the direction is vertical\n   * @param    {String}    direction\n   * @returns  {Boolean}   is_vertical\n   */\n  isVertical: function isVertical(direction) {\n    return direction == DIRECTION_UP || direction == DIRECTION_DOWN;\n  },\n\n\n  /**\n   * toggle browser default behavior with css props\n   * @param   {HtmlElement}   element\n   * @param   {Object}        css_props\n   * @param   {Boolean}       toggle\n   */\n  toggleDefaultBehavior: function toggleDefaultBehavior(element, css_props, toggle) {\n    if(!css_props || !element || !element.style) {\n      return;\n    }\n\n    // with css properties for modern browsers\n    Utils.each(['webkit', 'moz', 'Moz', 'ms', 'o', ''], function setStyle(vendor) {\n      Utils.each(css_props, function(value, prop) {\n          // vender prefix at the property\n          if(vendor) {\n            prop = vendor + prop.substring(0, 1).toUpperCase() + prop.substring(1);\n          }\n          // set the style\n          if(prop in element.style) {\n            element.style[prop] = !toggle && value;\n          }\n      });\n    });\n\n    var false_fn = function(){ return false; };\n\n    // also the disable onselectstart\n    if(css_props.userSelect == 'none') {\n      element.onselectstart = !toggle && false_fn;\n    }\n    // and disable ondragstart\n    if(css_props.userDrag == 'none') {\n      element.ondragstart = !toggle && false_fn;\n    }\n  }\n};\n\n\n/**\n * create new hammer instance\n * all methods should return the instance itself, so it is chainable.\n * @param   {HTMLElement}       element\n * @param   {Object}            [options={}]\n * @returns {Hammer.Instance}\n * @constructor\n */\nHammer.Instance = function(element, options) {\n  var self = this;\n\n  // setup HammerJS window events and register all gestures\n  // this also sets up the default options\n  setup();\n\n  this.element = element;\n\n  // start/stop detection option\n  this.enabled = true;\n\n  // merge options\n  this.options = Utils.extend(\n    Utils.extend({}, Hammer.defaults),\n    options || {});\n\n  // add some css to the element to prevent the browser from doing its native behavoir\n  if(this.options.stop_browser_behavior) {\n    Utils.toggleDefaultBehavior(this.element, this.options.stop_browser_behavior, false);\n  }\n\n  // start detection on touchstart\n  this.eventStartHandler = Event.onTouch(element, EVENT_START, function(ev) {\n    if(self.enabled) {\n      Detection.startDetect(self, ev);\n    }\n  });\n\n  // keep a list of user event handlers which needs to be removed when calling 'dispose'\n  this.eventHandlers = [];\n\n  // return instance\n  return this;\n};\n\n\nHammer.Instance.prototype = {\n  /**\n   * bind events to the instance\n   * @param   {String}      gesture\n   * @param   {Function}    handler\n   * @returns {Hammer.Instance}\n   */\n  on: function onEvent(gesture, handler) {\n    var gestures = gesture.split(' ');\n    Utils.each(gestures, function(gesture) {\n      this.element.addEventListener(gesture, handler, false);\n      this.eventHandlers.push({ gesture: gesture, handler: handler });\n    }, this);\n    return this;\n  },\n\n\n  /**\n   * unbind events to the instance\n   * @param   {String}      gesture\n   * @param   {Function}    handler\n   * @returns {Hammer.Instance}\n   */\n  off: function offEvent(gesture, handler) {\n    var gestures = gesture.split(' ')\n      , i, eh;\n    Utils.each(gestures, function(gesture) {\n      this.element.removeEventListener(gesture, handler, false);\n\n      // remove the event handler from the internal list\n      for(i=-1; (eh=this.eventHandlers[++i]);) {\n        if(eh.gesture === gesture && eh.handler === handler) {\n          this.eventHandlers.splice(i, 1);\n        }\n      }\n    }, this);\n    return this;\n  },\n\n\n  /**\n   * trigger gesture event\n   * @param   {String}      gesture\n   * @param   {Object}      [eventData]\n   * @returns {Hammer.Instance}\n   */\n  trigger: function triggerEvent(gesture, eventData) {\n    // optional\n    if(!eventData) {\n      eventData = {};\n    }\n\n    // create DOM event\n    var event = Hammer.DOCUMENT.createEvent('Event');\n    event.initEvent(gesture, true, true);\n    event.gesture = eventData;\n\n    // trigger on the target if it is in the instance element,\n    // this is for event delegation tricks\n    var element = this.element;\n    if(Utils.hasParent(eventData.target, element)) {\n      element = eventData.target;\n    }\n\n    element.dispatchEvent(event);\n    return this;\n  },\n\n\n  /**\n   * enable of disable hammer.js detection\n   * @param   {Boolean}   state\n   * @returns {Hammer.Instance}\n   */\n  enable: function enable(state) {\n    this.enabled = state;\n    return this;\n  },\n\n\n  /**\n   * dispose this hammer instance\n   * @returns {Hammer.Instance}\n   */\n  dispose: function dispose() {\n    var i, eh;\n\n    // undo all changes made by stop_browser_behavior\n    if(this.options.stop_browser_behavior) {\n      Utils.toggleDefaultBehavior(this.element, this.options.stop_browser_behavior, true);\n    }\n\n    // unbind all custom event handlers\n    for(i=-1; (eh=this.eventHandlers[++i]);) {\n      this.element.removeEventListener(eh.gesture, eh.handler, false);\n    }\n    this.eventHandlers = [];\n\n    // unbind the start event listener\n    Event.unbindDom(this.element, Hammer.EVENT_TYPES[EVENT_START], this.eventStartHandler);\n\n    return null;\n  }\n};\n\n\n/**\n * this holds the last move event,\n * used to fix empty touchend issue\n * see the onTouch event for an explanation\n * @type {Object}\n */\nvar last_move_event = null;\n\n/**\n * when the mouse is hold down, this is true\n * @type {Boolean}\n */\nvar should_detect = false;\n\n/**\n * when touch events have been fired, this is true\n * @type {Boolean}\n */\nvar touch_triggered = false;\n\n\nvar Event = Hammer.event = {\n  /**\n   * simple addEventListener\n   * @param   {HTMLElement}   element\n   * @param   {String}        type\n   * @param   {Function}      handler\n   */\n  bindDom: function(element, type, handler) {\n    var types = type.split(' ');\n    Utils.each(types, function(type){\n      element.addEventListener(type, handler, false);\n    });\n  },\n\n\n  /**\n   * simple removeEventListener\n   * @param   {HTMLElement}   element\n   * @param   {String}        type\n   * @param   {Function}      handler\n   */\n  unbindDom: function(element, type, handler) {\n    var types = type.split(' ');\n    Utils.each(types, function(type){\n      element.removeEventListener(type, handler, false);\n    });\n  },\n\n\n  /**\n   * touch events with mouse fallback\n   * @param   {HTMLElement}   element\n   * @param   {String}        eventType        like EVENT_MOVE\n   * @param   {Function}      handler\n   */\n  onTouch: function onTouch(element, eventType, handler) {\n    var self = this;\n\n\n    var bindDomOnTouch = function bindDomOnTouch(ev) {\n      var srcEventType = ev.type.toLowerCase();\n\n      // onmouseup, but when touchend has been fired we do nothing.\n      // this is for touchdevices which also fire a mouseup on touchend\n      if(Utils.inStr(srcEventType, 'mouse') && touch_triggered) {\n        return;\n      }\n\n      // mousebutton must be down or a touch event\n      else if(Utils.inStr(srcEventType, 'touch') ||   // touch events are always on screen\n        Utils.inStr(srcEventType, 'pointerdown') || // pointerevents touch\n        (Utils.inStr(srcEventType, 'mouse') && ev.which === 1)   // mouse is pressed\n        ) {\n        should_detect = true;\n      }\n\n      // mouse isn't pressed\n      else if(Utils.inStr(srcEventType, 'mouse') && !ev.which) {\n        should_detect = false;\n      }\n\n\n      // we are in a touch event, set the touch triggered bool to true,\n      // this for the conflicts that may occur on ios and android\n      if(Utils.inStr(srcEventType, 'touch') || Utils.inStr(srcEventType, 'pointer')) {\n        touch_triggered = true;\n      }\n\n      // count the total touches on the screen\n      var count_touches = 0;\n\n      // when touch has been triggered in this detection session\n      // and we are now handling a mouse event, we stop that to prevent conflicts\n      if(should_detect) {\n        // update pointerevent\n        if(Hammer.HAS_POINTEREVENTS && eventType != EVENT_END) {\n          count_touches = PointerEvent.updatePointer(eventType, ev);\n        }\n        // touch\n        else if(Utils.inStr(srcEventType, 'touch')) {\n          count_touches = ev.touches.length;\n        }\n        // mouse\n        else if(!touch_triggered) {\n          count_touches = Utils.inStr(srcEventType, 'up') ? 0 : 1;\n        }\n\n\n        // if we are in a end event, but when we remove one touch and\n        // we still have enough, set eventType to move\n        if(count_touches > 0 && eventType == EVENT_END) {\n          eventType = EVENT_MOVE;\n        }\n        // no touches, force the end event\n        else if(!count_touches) {\n          eventType = EVENT_END;\n        }\n\n        // store the last move event\n        if(count_touches || last_move_event === null) {\n          last_move_event = ev;\n        }\n\n\n        // trigger the handler\n        handler.call(Detection, self.collectEventData(element, eventType,\n                                  self.getTouchList(last_move_event, eventType),\n                                  ev) );\n\n        // remove pointerevent from list\n        if(Hammer.HAS_POINTEREVENTS && eventType == EVENT_END) {\n          count_touches = PointerEvent.updatePointer(eventType, ev);\n        }\n      }\n\n      // on the end we reset everything\n      if(!count_touches) {\n        last_move_event = null;\n        should_detect = false;\n        touch_triggered = false;\n        PointerEvent.reset();\n      }\n    };\n\n    this.bindDom(element, Hammer.EVENT_TYPES[eventType], bindDomOnTouch);\n\n    // return the bound function to be able to unbind it later\n    return bindDomOnTouch;\n  },\n\n\n  /**\n   * we have different events for each device/browser\n   * determine what we need and set them in the Hammer.EVENT_TYPES constant\n   */\n  determineEventTypes: function determineEventTypes() {\n    // determine the eventtype we want to set\n    var types;\n\n    // pointerEvents magic\n    if(Hammer.HAS_POINTEREVENTS) {\n      types = PointerEvent.getEvents();\n    }\n    // on Android, iOS, blackberry, windows mobile we dont want any mouseevents\n    else if(Hammer.NO_MOUSEEVENTS) {\n      types = [\n        'touchstart',\n        'touchmove',\n        'touchend touchcancel'];\n    }\n    // for non pointer events browsers and mixed browsers,\n    // like chrome on windows8 touch laptop\n    else {\n      types = [\n        'touchstart mousedown',\n        'touchmove mousemove',\n        'touchend touchcancel mouseup'];\n    }\n\n    Hammer.EVENT_TYPES[EVENT_START] = types[0];\n    Hammer.EVENT_TYPES[EVENT_MOVE] = types[1];\n    Hammer.EVENT_TYPES[EVENT_END] = types[2];\n  },\n\n\n  /**\n   * create touchlist depending on the event\n   * @param   {Object}    ev\n   * @param   {String}    eventType   used by the fakemultitouch plugin\n   */\n  getTouchList: function getTouchList(ev/*, eventType*/) {\n    // get the fake pointerEvent touchlist\n    if(Hammer.HAS_POINTEREVENTS) {\n      return PointerEvent.getTouchList();\n    }\n\n    // get the touchlist\n    if(ev.touches) {\n      return ev.touches;\n    }\n\n    // make fake touchlist from mouse position\n    ev.identifier = 1;\n    return [ev];\n  },\n\n\n  /**\n   * collect event data for Hammer js\n   * @param   {HTMLElement}   element\n   * @param   {String}        eventType        like EVENT_MOVE\n   * @param   {Object}        eventData\n   */\n  collectEventData: function collectEventData(element, eventType, touches, ev) {\n    // find out pointerType\n    var pointerType = POINTER_TOUCH;\n    if(Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {\n      pointerType = POINTER_MOUSE;\n    }\n\n    return {\n      center     : Utils.getCenter(touches),\n      timeStamp  : Date.now(),\n      target     : ev.target,\n      touches    : touches,\n      eventType  : eventType,\n      pointerType: pointerType,\n      srcEvent   : ev,\n\n      /**\n       * prevent the browser default actions\n       * mostly used to disable scrolling of the browser\n       */\n      preventDefault: function() {\n        var srcEvent = this.srcEvent;\n        srcEvent.preventManipulation && srcEvent.preventManipulation();\n        srcEvent.preventDefault && srcEvent.preventDefault();\n      },\n\n      /**\n       * stop bubbling the event up to its parents\n       */\n      stopPropagation: function() {\n        this.srcEvent.stopPropagation();\n      },\n\n      /**\n       * immediately stop gesture detection\n       * might be useful after a swipe was detected\n       * @return {*}\n       */\n      stopDetect: function() {\n        return Detection.stopDetect();\n      }\n    };\n  }\n};\n\nvar PointerEvent = Hammer.PointerEvent = {\n  /**\n   * holds all pointers\n   * @type {Object}\n   */\n  pointers: {},\n\n  /**\n   * get a list of pointers\n   * @returns {Array}     touchlist\n   */\n  getTouchList: function getTouchList() {\n    var touchlist = [];\n    // we can use forEach since pointerEvents only is in IE10\n    Utils.each(this.pointers, function(pointer){\n      touchlist.push(pointer);\n    });\n\n    return touchlist;\n  },\n\n  /**\n   * update the position of a pointer\n   * @param   {String}   type             EVENT_END\n   * @param   {Object}   pointerEvent\n   */\n  updatePointer: function updatePointer(type, pointerEvent) {\n    if(type == EVENT_END) {\n      delete this.pointers[pointerEvent.pointerId];\n    }\n    else {\n      pointerEvent.identifier = pointerEvent.pointerId;\n      this.pointers[pointerEvent.pointerId] = pointerEvent;\n    }\n\n    // it's save to use Object.keys, since pointerEvents are only in newer browsers\n    return Object.keys(this.pointers).length;\n  },\n\n  /**\n   * check if ev matches pointertype\n   * @param   {String}        pointerType     POINTER_MOUSE\n   * @param   {PointerEvent}  ev\n   */\n  matchType: function matchType(pointerType, ev) {\n    if(!ev.pointerType) {\n      return false;\n    }\n\n    var pt = ev.pointerType\n      , types = {};\n\n    types[POINTER_MOUSE] = (pt === POINTER_MOUSE);\n    types[POINTER_TOUCH] = (pt === POINTER_TOUCH);\n    types[POINTER_PEN] = (pt === POINTER_PEN);\n    return types[pointerType];\n  },\n\n\n  /**\n   * get events\n   */\n  getEvents: function getEvents() {\n    return [\n      'pointerdown MSPointerDown',\n      'pointermove MSPointerMove',\n      'pointerup pointercancel MSPointerUp MSPointerCancel'\n    ];\n  },\n\n  /**\n   * reset the list\n   */\n  reset: function resetList() {\n    this.pointers = {};\n  }\n};\n\n\nvar Detection = Hammer.detection = {\n  // contains all registred Hammer.gestures in the correct order\n  gestures: [],\n\n  // data of the current Hammer.gesture detection session\n  current : null,\n\n  // the previous Hammer.gesture session data\n  // is a full clone of the previous gesture.current object\n  previous: null,\n\n  // when this becomes true, no gestures are fired\n  stopped : false,\n\n\n  /**\n   * start Hammer.gesture detection\n   * @param   {Hammer.Instance}   inst\n   * @param   {Object}            eventData\n   */\n  startDetect: function startDetect(inst, eventData) {\n    // already busy with a Hammer.gesture detection on an element\n    if(this.current) {\n      return;\n    }\n\n    this.stopped = false;\n\n    // holds current session\n    this.current = {\n      inst              : inst, // reference to HammerInstance we're working for\n      startEvent        : Utils.extend({}, eventData), // start eventData for distances, timing etc\n      lastEvent         : false, // last eventData\n      lastVelocityEvent : false, // last eventData for velocity.\n      velocity          : false, // current velocity\n      name              : '' // current gesture we're in/detected, can be 'tap', 'hold' etc\n    };\n\n    this.detect(eventData);\n  },\n\n\n  /**\n   * Hammer.gesture detection\n   * @param   {Object}    eventData\n   */\n  detect: function detect(eventData) {\n    if(!this.current || this.stopped) {\n      return;\n    }\n\n    // extend event data with calculations about scale, distance etc\n    eventData = this.extendEventData(eventData);\n\n    // hammer instance and instance options\n    var inst = this.current.inst,\n        inst_options = inst.options;\n\n    // call Hammer.gesture handlers\n    Utils.each(this.gestures, function triggerGesture(gesture) {\n      // only when the instance options have enabled this gesture\n      if(!this.stopped && inst_options[gesture.name] !== false && inst.enabled !== false ) {\n        // if a handler returns false, we stop with the detection\n        if(gesture.handler.call(gesture, eventData, inst) === false) {\n          this.stopDetect();\n          return false;\n        }\n      }\n    }, this);\n\n    // store as previous event event\n    if(this.current) {\n      this.current.lastEvent = eventData;\n    }\n\n    // end event, but not the last touch, so dont stop\n    if(eventData.eventType == EVENT_END && !eventData.touches.length - 1) {\n      this.stopDetect();\n    }\n\n    return eventData;\n  },\n\n\n  /**\n   * clear the Hammer.gesture vars\n   * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected\n   * to stop other Hammer.gestures from being fired\n   */\n  stopDetect: function stopDetect() {\n    // clone current data to the store as the previous gesture\n    // used for the double tap gesture, since this is an other gesture detect session\n    this.previous = Utils.extend({}, this.current);\n\n    // reset the current\n    this.current = null;\n\n    // stopped!\n    this.stopped = true;\n  },\n\n\n  /**\n   * calculate velocity\n   * @param   {Object}  ev\n   * @param   {Number}  delta_time\n   * @param   {Number}  delta_x\n   * @param   {Number}  delta_y\n   */\n  getVelocityData: function getVelocityData(ev, delta_time, delta_x, delta_y) {\n    var cur = this.current\n      , velocityEv = cur.lastVelocityEvent\n      , velocity = cur.velocity;\n\n    // calculate velocity every x ms\n    if (velocityEv && ev.timeStamp - velocityEv.timeStamp > Hammer.UPDATE_VELOCITY_INTERVAL) {\n      velocity = Utils.getVelocity(ev.timeStamp - velocityEv.timeStamp,\n                                   ev.center.clientX - velocityEv.center.clientX,\n                                  ev.center.clientY - velocityEv.center.clientY);\n      cur.lastVelocityEvent = ev;\n    }\n    else if(!cur.velocity) {\n      velocity = Utils.getVelocity(delta_time, delta_x, delta_y);\n      cur.lastVelocityEvent = ev;\n    }\n\n    cur.velocity = velocity;\n\n    ev.velocityX = velocity.x;\n    ev.velocityY = velocity.y;\n  },\n\n\n  /**\n   * calculate interim angle and direction\n   * @param   {Object}  ev\n   */\n  getInterimData: function getInterimData(ev) {\n    var lastEvent = this.current.lastEvent\n      , angle\n      , direction;\n\n    // end events (e.g. dragend) don't have useful values for interimDirection & interimAngle\n    // because the previous event has exactly the same coordinates\n    // so for end events, take the previous values of interimDirection & interimAngle\n    // instead of recalculating them and getting a spurious '0'\n    if(ev.eventType == EVENT_END) {\n      angle = lastEvent && lastEvent.interimAngle;\n      direction = lastEvent && lastEvent.interimDirection;\n    }\n    else {\n      angle = lastEvent && Utils.getAngle(lastEvent.center, ev.center);\n      direction = lastEvent && Utils.getDirection(lastEvent.center, ev.center);\n    }\n\n    ev.interimAngle = angle;\n    ev.interimDirection = direction;\n  },\n\n\n  /**\n   * extend eventData for Hammer.gestures\n   * @param   {Object}   evData\n   * @returns {Object}   evData\n   */\n  extendEventData: function extendEventData(ev) {\n    var cur = this.current\n      , startEv = cur.startEvent;\n\n    // if the touches change, set the new touches over the startEvent touches\n    // this because touchevents don't have all the touches on touchstart, or the\n    // user must place his fingers at the EXACT same time on the screen, which is not realistic\n    // but, sometimes it happens that both fingers are touching at the EXACT same time\n    if(ev.touches.length != startEv.touches.length || ev.touches === startEv.touches) {\n      // extend 1 level deep to get the touchlist with the touch objects\n      startEv.touches = [];\n      Utils.each(ev.touches, function(touch) {\n        startEv.touches.push(Utils.extend({}, touch));\n      });\n    }\n\n    var delta_time = ev.timeStamp - startEv.timeStamp\n      , delta_x = ev.center.clientX - startEv.center.clientX\n      , delta_y = ev.center.clientY - startEv.center.clientY;\n\n    this.getVelocityData(ev, delta_time, delta_x, delta_y);\n    this.getInterimData(ev);\n\n    Utils.extend(ev, {\n      startEvent: startEv,\n\n      deltaTime : delta_time,\n      deltaX    : delta_x,\n      deltaY    : delta_y,\n\n      distance  : Utils.getDistance(startEv.center, ev.center),\n      angle     : Utils.getAngle(startEv.center, ev.center),\n      direction : Utils.getDirection(startEv.center, ev.center),\n\n      scale     : Utils.getScale(startEv.touches, ev.touches),\n      rotation  : Utils.getRotation(startEv.touches, ev.touches)\n    });\n\n    return ev;\n  },\n\n\n  /**\n   * register new gesture\n   * @param   {Object}    gesture object, see gestures.js for documentation\n   * @returns {Array}     gestures\n   */\n  register: function register(gesture) {\n    // add an enable gesture options if there is no given\n    var options = gesture.defaults || {};\n    if(options[gesture.name] === undefined) {\n      options[gesture.name] = true;\n    }\n\n    // extend Hammer default options with the Hammer.gesture options\n    Utils.extend(Hammer.defaults, options, true);\n\n    // set its index\n    gesture.index = gesture.index || 1000;\n\n    // add Hammer.gesture to the list\n    this.gestures.push(gesture);\n\n    // sort the list by index\n    this.gestures.sort(function(a, b) {\n      if(a.index < b.index) { return -1; }\n      if(a.index > b.index) { return 1; }\n      return 0;\n    });\n\n    return this.gestures;\n  }\n};\n\n\n/**\n * Drag\n * Move with x fingers (default 1) around on the page. Blocking the scrolling when\n * moving left and right is a good practice. When all the drag events are blocking\n * you disable scrolling on that area.\n * @events  drag, drapleft, dragright, dragup, dragdown\n */\nHammer.gestures.Drag = {\n  name     : 'drag',\n  index    : 50,\n  defaults : {\n    drag_min_distance            : 10,\n\n    // Set correct_for_drag_min_distance to true to make the starting point of the drag\n    // be calculated from where the drag was triggered, not from where the touch started.\n    // Useful to avoid a jerk-starting drag, which can make fine-adjustments\n    // through dragging difficult, and be visually unappealing.\n    correct_for_drag_min_distance: true,\n\n    // set 0 for unlimited, but this can conflict with transform\n    drag_max_touches             : 1,\n\n    // prevent default browser behavior when dragging occurs\n    // be careful with it, it makes the element a blocking element\n    // when you are using the drag gesture, it is a good practice to set this true\n    drag_block_horizontal        : false,\n    drag_block_vertical          : false,\n\n    // drag_lock_to_axis keeps the drag gesture on the axis that it started on,\n    // It disallows vertical directions if the initial direction was horizontal, and vice versa.\n    drag_lock_to_axis            : false,\n\n    // drag lock only kicks in when distance > drag_lock_min_distance\n    // This way, locking occurs only when the distance has become large enough to reliably determine the direction\n    drag_lock_min_distance       : 25\n  },\n\n  triggered: false,\n  handler  : function dragGesture(ev, inst) {\n    var cur = Detection.current;\n\n    // current gesture isnt drag, but dragged is true\n    // this means an other gesture is busy. now call dragend\n    if(cur.name != this.name && this.triggered) {\n      inst.trigger(this.name + 'end', ev);\n      this.triggered = false;\n      return;\n    }\n\n    // max touches\n    if(inst.options.drag_max_touches > 0 &&\n      ev.touches.length > inst.options.drag_max_touches) {\n      return;\n    }\n\n    switch(ev.eventType) {\n      case EVENT_START:\n        this.triggered = false;\n        break;\n\n      case EVENT_MOVE:\n        // when the distance we moved is too small we skip this gesture\n        // or we can be already in dragging\n        if(ev.distance < inst.options.drag_min_distance &&\n          cur.name != this.name) {\n          return;\n        }\n\n        var startCenter = cur.startEvent.center;\n\n        // we are dragging!\n        if(cur.name != this.name) {\n          cur.name = this.name;\n          if(inst.options.correct_for_drag_min_distance && ev.distance > 0) {\n            // When a drag is triggered, set the event center to drag_min_distance pixels from the original event center.\n            // Without this correction, the dragged distance would jumpstart at drag_min_distance pixels instead of at 0.\n            // It might be useful to save the original start point somewhere\n            var factor = Math.abs(inst.options.drag_min_distance / ev.distance);\n            startCenter.pageX += ev.deltaX * factor;\n            startCenter.pageY += ev.deltaY * factor;\n            startCenter.clientX += ev.deltaX * factor;\n            startCenter.clientY += ev.deltaY * factor;\n\n            // recalculate event data using new start point\n            ev = Detection.extendEventData(ev);\n          }\n        }\n\n        // lock drag to axis?\n        if(cur.lastEvent.drag_locked_to_axis ||\n            ( inst.options.drag_lock_to_axis &&\n              inst.options.drag_lock_min_distance <= ev.distance\n            )) {\n          ev.drag_locked_to_axis = true;\n        }\n        var last_direction = cur.lastEvent.direction;\n        if(ev.drag_locked_to_axis && last_direction !== ev.direction) {\n          // keep direction on the axis that the drag gesture started on\n          if(Utils.isVertical(last_direction)) {\n            ev.direction = (ev.deltaY < 0) ? DIRECTION_UP : DIRECTION_DOWN;\n          }\n          else {\n            ev.direction = (ev.deltaX < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          }\n        }\n\n        // first time, trigger dragstart event\n        if(!this.triggered) {\n          inst.trigger(this.name + 'start', ev);\n          this.triggered = true;\n        }\n\n        // trigger events\n        inst.trigger(this.name, ev);\n        inst.trigger(this.name + ev.direction, ev);\n\n        var is_vertical = Utils.isVertical(ev.direction);\n\n        // block the browser events\n        if((inst.options.drag_block_vertical && is_vertical) ||\n          (inst.options.drag_block_horizontal && !is_vertical)) {\n          ev.preventDefault();\n        }\n        break;\n\n      case EVENT_END:\n        // trigger dragend\n        if(this.triggered) {\n          inst.trigger(this.name + 'end', ev);\n        }\n\n        this.triggered = false;\n        break;\n    }\n  }\n};\n\n/**\n * Hold\n * Touch stays at the same place for x time\n * @events  hold\n */\nHammer.gestures.Hold = {\n  name    : 'hold',\n  index   : 10,\n  defaults: {\n    hold_timeout  : 500,\n    hold_threshold: 2\n  },\n  timer   : null,\n\n  handler : function holdGesture(ev, inst) {\n    switch(ev.eventType) {\n      case EVENT_START:\n        // clear any running timers\n        clearTimeout(this.timer);\n\n        // set the gesture so we can check in the timeout if it still is\n        Detection.current.name = this.name;\n\n        // set timer and if after the timeout it still is hold,\n        // we trigger the hold event\n        this.timer = setTimeout(function() {\n          if(Detection.current.name == 'hold') {\n            inst.trigger('hold', ev);\n          }\n        }, inst.options.hold_timeout);\n        break;\n\n      // when you move or end we clear the timer\n      case EVENT_MOVE:\n        if(ev.distance > inst.options.hold_threshold) {\n          clearTimeout(this.timer);\n        }\n        break;\n\n      case EVENT_END:\n        clearTimeout(this.timer);\n        break;\n    }\n  }\n};\n\n/**\n * Release\n * Called as last, tells the user has released the screen\n * @events  release\n */\nHammer.gestures.Release = {\n  name   : 'release',\n  index  : Infinity,\n  handler: function releaseGesture(ev, inst) {\n    if(ev.eventType == EVENT_END) {\n      inst.trigger(this.name, ev);\n    }\n  }\n};\n\n/**\n * Swipe\n * triggers swipe events when the end velocity is above the threshold\n * for best usage, set prevent_default (on the drag gesture) to true\n * @events  swipe, swipeleft, swiperight, swipeup, swipedown\n */\nHammer.gestures.Swipe = {\n  name    : 'swipe',\n  index   : 40,\n  defaults: {\n    swipe_min_touches: 1,\n    swipe_max_touches: 1,\n    swipe_velocity   : 0.7\n  },\n  handler : function swipeGesture(ev, inst) {\n    if(ev.eventType == EVENT_END) {\n      // max touches\n      if(ev.touches.length < inst.options.swipe_min_touches ||\n        ev.touches.length > inst.options.swipe_max_touches) {\n        return;\n      }\n\n      // when the distance we moved is too small we skip this gesture\n      // or we can be already in dragging\n      if(ev.velocityX > inst.options.swipe_velocity ||\n        ev.velocityY > inst.options.swipe_velocity) {\n        // trigger swipe events\n        inst.trigger(this.name, ev);\n        inst.trigger(this.name + ev.direction, ev);\n      }\n    }\n  }\n};\n\n/**\n * Tap/DoubleTap\n * Quick touch at a place or double at the same place\n * @events  tap, doubletap\n */\nHammer.gestures.Tap = {\n  name    : 'tap',\n  index   : 100,\n  defaults: {\n    tap_max_touchtime : 250,\n    tap_max_distance  : 10,\n    tap_always        : true,\n    doubletap_distance: 20,\n    doubletap_interval: 300\n  },\n\n  has_moved: false,\n\n  handler : function tapGesture(ev, inst) {\n    var prev, since_prev, did_doubletap;\n\n    // reset moved state\n    if(ev.eventType == EVENT_START) {\n      this.has_moved = false;\n    }\n\n    // Track the distance we've moved. If it's above the max ONCE, remember that (fixes #406).\n    else if(ev.eventType == EVENT_MOVE && !this.moved) {\n      this.has_moved = (ev.distance > inst.options.tap_max_distance);\n    }\n\n    else if(ev.eventType == EVENT_END &&\n        ev.srcEvent.type != 'touchcancel' &&\n        ev.deltaTime < inst.options.tap_max_touchtime && !this.has_moved) {\n\n      // previous gesture, for the double tap since these are two different gesture detections\n      prev = Detection.previous;\n      since_prev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;\n      did_doubletap = false;\n\n      // check if double tap\n      if(prev && prev.name == 'tap' &&\n          (since_prev && since_prev < inst.options.doubletap_interval) &&\n          ev.distance < inst.options.doubletap_distance) {\n        inst.trigger('doubletap', ev);\n        did_doubletap = true;\n      }\n\n      // do a single tap\n      if(!did_doubletap || inst.options.tap_always) {\n        Detection.current.name = 'tap';\n        inst.trigger(Detection.current.name, ev);\n      }\n    }\n  }\n};\n\n/**\n * Touch\n * Called as first, tells the user has touched the screen\n * @events  touch\n */\nHammer.gestures.Touch = {\n  name    : 'touch',\n  index   : -Infinity,\n  defaults: {\n    // call preventDefault at touchstart, and makes the element blocking by\n    // disabling the scrolling of the page, but it improves gestures like\n    // transforming and dragging.\n    // be careful with using this, it can be very annoying for users to be stuck\n    // on the page\n    prevent_default    : false,\n\n    // disable mouse events, so only touch (or pen!) input triggers events\n    prevent_mouseevents: false\n  },\n  handler : function touchGesture(ev, inst) {\n    if(inst.options.prevent_mouseevents &&\n        ev.pointerType == POINTER_MOUSE) {\n      ev.stopDetect();\n      return;\n    }\n\n    if(inst.options.prevent_default) {\n      ev.preventDefault();\n    }\n\n    if(ev.eventType == EVENT_START) {\n      inst.trigger(this.name, ev);\n    }\n  }\n};\n\n\n/**\n * Transform\n * User want to scale or rotate with 2 fingers\n * @events  transform, pinch, pinchin, pinchout, rotate\n */\nHammer.gestures.Transform = {\n  name     : 'transform',\n  index    : 45,\n  defaults : {\n    // factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1\n    transform_min_scale      : 0.01,\n    // rotation in degrees\n    transform_min_rotation   : 1,\n    // prevent default browser behavior when two touches are on the screen\n    // but it makes the element a blocking element\n    // when you are using the transform gesture, it is a good practice to set this true\n    transform_always_block   : false,\n    // ensures that all touches occurred within the instance element\n    transform_within_instance: false\n  },\n\n  triggered: false,\n\n  handler  : function transformGesture(ev, inst) {\n    // current gesture isnt drag, but dragged is true\n    // this means an other gesture is busy. now call dragend\n    if(Detection.current.name != this.name && this.triggered) {\n      inst.trigger(this.name + 'end', ev);\n      this.triggered = false;\n      return;\n    }\n\n    // at least multitouch\n    if(ev.touches.length < 2) {\n      return;\n    }\n\n    // prevent default when two fingers are on the screen\n    if(inst.options.transform_always_block) {\n      ev.preventDefault();\n    }\n\n    // check if all touches occurred within the instance element\n    if(inst.options.transform_within_instance) {\n      for(var i=-1; ev.touches[++i];) {\n        if(!Utils.hasParent(ev.touches[i].target, inst.element)) {\n          return;\n        }\n      }\n    }\n\n    switch(ev.eventType) {\n      case EVENT_START:\n        this.triggered = false;\n        break;\n\n      case EVENT_MOVE:\n        var scale_threshold = Math.abs(1 - ev.scale);\n        var rotation_threshold = Math.abs(ev.rotation);\n\n        // when the distance we moved is too small we skip this gesture\n        // or we can be already in dragging\n        if(scale_threshold < inst.options.transform_min_scale &&\n          rotation_threshold < inst.options.transform_min_rotation) {\n          return;\n        }\n\n        // we are transforming!\n        Detection.current.name = this.name;\n\n        // first time, trigger dragstart event\n        if(!this.triggered) {\n          inst.trigger(this.name + 'start', ev);\n          this.triggered = true;\n        }\n\n        inst.trigger(this.name, ev); // basic transform event\n\n        // trigger rotate event\n        if(rotation_threshold > inst.options.transform_min_rotation) {\n          inst.trigger('rotate', ev);\n        }\n\n        // trigger pinch event\n        if(scale_threshold > inst.options.transform_min_scale) {\n          inst.trigger('pinch', ev);\n          inst.trigger('pinch' + (ev.scale<1 ? 'in' : 'out'), ev);\n        }\n        break;\n\n      case EVENT_END:\n        // trigger dragend\n        if(this.triggered) {\n          inst.trigger(this.name + 'end', ev);\n        }\n\n        this.triggered = false;\n        break;\n    }\n  }\n};\n\n// AMD export\nif(typeof define == 'function' && define.amd) {\n  define(function(){\n    return Hammer;\n  });\n}\n// commonjs export\nelse if(typeof module == 'object' && module.exports) {\n  module.exports = Hammer;\n}\n// browser export\nelse {\n  window.Hammer = Hammer;\n}\n\n})(window);\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../pink/~/hammerjs/hammer.js\n ** module id = 10\n ** module chunks = 0\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function addStyle(cssCode) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\tvar styleElement = document.createElement(\"style\"),\r\n\t\thead = document.head || document.getElementsByTagName(\"head\")[0];\r\n\tstyleElement.type = \"text/css\";\r\n\thead.appendChild(styleElement);\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = cssCode;\r\n\t} else {\r\n\t\tstyleElement.appendChild(document.createTextNode(cssCode));\r\n\t}\r\n\tif(module.hot) {\r\n\t\treturn function(cssCode) {\r\n\t\t\tif(typeof cssCode === \"string\") {\r\n\t\t\t\tif (styleElement.styleSheet) {\r\n\t\t\t\t\tstyleElement.styleSheet.cssText = cssCode;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstyleElement.childNodes[0].nodeValue = cssCode;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tdispose();\r\n\t\t\t}\r\n\t\t};\r\n\t} else {\r\n\t\t// For the useable API, provide a function to remove the stylesheet.\r\n\t\treturn dispose;\r\n\t}\r\n\r\n\tfunction dispose() {\r\n\t\thead.removeChild(styleElement);\r\n\t}\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../pink/~/style-loader/addStyle.js\n ** module id = 11\n ** module chunks = 0\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\nvar update = require(\"!/home/bodil/workspace/pink/node_modules/style-loader/addStyle.js\")(\n\trequire(\"!!/home/bodil/workspace/pink/node_modules/css-loader/index.js!/home/bodil/workspace/pink/node_modules/less-loader/index.js!/home/bodil/workspace/pink/css/screen.less\")\n);\n// Hot Module Replacement\nif(module.hot) {\n\tmodule.hot.accept(\"!!/home/bodil/workspace/pink/node_modules/css-loader/index.js!/home/bodil/workspace/pink/node_modules/less-loader/index.js!/home/bodil/workspace/pink/css/screen.less\", function() {\n\t\tupdate(require(\"!!/home/bodil/workspace/pink/node_modules/css-loader/index.js!/home/bodil/workspace/pink/node_modules/less-loader/index.js!/home/bodil/workspace/pink/css/screen.less\"));\n\t});\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../pink/css/screen.less\n ** module id = 12\n ** module chunks = 0\n **/","(function(global) {\n  'use strict';\n  if (global.$traceurRuntime) {\n    return;\n  }\n  var $Object = Object;\n  var $TypeError = TypeError;\n  var $create = $Object.create;\n  var $defineProperties = $Object.defineProperties;\n  var $defineProperty = $Object.defineProperty;\n  var $freeze = $Object.freeze;\n  var $getOwnPropertyDescriptor = $Object.getOwnPropertyDescriptor;\n  var $getOwnPropertyNames = $Object.getOwnPropertyNames;\n  var $getPrototypeOf = $Object.getPrototypeOf;\n  var $hasOwnProperty = $Object.prototype.hasOwnProperty;\n  var $toString = $Object.prototype.toString;\n  function nonEnum(value) {\n    return {\n      configurable: true,\n      enumerable: false,\n      value: value,\n      writable: true\n    };\n  }\n  var method = nonEnum;\n  var counter = 0;\n  function newUniqueString() {\n    return '__$' + Math.floor(Math.random() * 1e9) + '$' + ++counter + '$__';\n  }\n  var symbolInternalProperty = newUniqueString();\n  var symbolDescriptionProperty = newUniqueString();\n  var symbolDataProperty = newUniqueString();\n  var symbolValues = $create(null);\n  function isSymbol(symbol) {\n    return typeof symbol === 'object' && symbol instanceof SymbolValue;\n  }\n  function typeOf(v) {\n    if (isSymbol(v))\n      return 'symbol';\n    return typeof v;\n  }\n  function Symbol(description) {\n    var value = new SymbolValue(description);\n    if (!(this instanceof Symbol))\n      return value;\n    throw new TypeError('Symbol cannot be new\\'ed');\n  }\n  $defineProperty(Symbol.prototype, 'constructor', nonEnum(Symbol));\n  $defineProperty(Symbol.prototype, 'toString', method(function() {\n    var symbolValue = this[symbolDataProperty];\n    if (!getOption('symbols'))\n      return symbolValue[symbolInternalProperty];\n    if (!symbolValue)\n      throw TypeError('Conversion from symbol to string');\n    var desc = symbolValue[symbolDescriptionProperty];\n    if (desc === undefined)\n      desc = '';\n    return 'Symbol(' + desc + ')';\n  }));\n  $defineProperty(Symbol.prototype, 'valueOf', method(function() {\n    var symbolValue = this[symbolDataProperty];\n    if (!symbolValue)\n      throw TypeError('Conversion from symbol to string');\n    if (!getOption('symbols'))\n      return symbolValue[symbolInternalProperty];\n    return symbolValue;\n  }));\n  function SymbolValue(description) {\n    var key = newUniqueString();\n    $defineProperty(this, symbolDataProperty, {value: this});\n    $defineProperty(this, symbolInternalProperty, {value: key});\n    $defineProperty(this, symbolDescriptionProperty, {value: description});\n    $freeze(this);\n    symbolValues[key] = this;\n  }\n  $defineProperty(SymbolValue.prototype, 'constructor', nonEnum(Symbol));\n  $defineProperty(SymbolValue.prototype, 'toString', {\n    value: Symbol.prototype.toString,\n    enumerable: false\n  });\n  $defineProperty(SymbolValue.prototype, 'valueOf', {\n    value: Symbol.prototype.valueOf,\n    enumerable: false\n  });\n  $freeze(SymbolValue.prototype);\n  Symbol.iterator = Symbol();\n  function toProperty(name) {\n    if (isSymbol(name))\n      return name[symbolInternalProperty];\n    return name;\n  }\n  function getOwnPropertyNames(object) {\n    var rv = [];\n    var names = $getOwnPropertyNames(object);\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      if (!symbolValues[name])\n        rv.push(name);\n    }\n    return rv;\n  }\n  function getOwnPropertyDescriptor(object, name) {\n    return $getOwnPropertyDescriptor(object, toProperty(name));\n  }\n  function getOwnPropertySymbols(object) {\n    var rv = [];\n    var names = $getOwnPropertyNames(object);\n    for (var i = 0; i < names.length; i++) {\n      var symbol = symbolValues[names[i]];\n      if (symbol)\n        rv.push(symbol);\n    }\n    return rv;\n  }\n  function hasOwnProperty(name) {\n    return $hasOwnProperty.call(this, toProperty(name));\n  }\n  function getOption(name) {\n    return global.traceur && global.traceur.options[name];\n  }\n  function setProperty(object, name, value) {\n    var sym,\n        desc;\n    if (isSymbol(name)) {\n      sym = name;\n      name = name[symbolInternalProperty];\n    }\n    object[name] = value;\n    if (sym && (desc = $getOwnPropertyDescriptor(object, name)))\n      $defineProperty(object, name, {enumerable: false});\n    return value;\n  }\n  function defineProperty(object, name, descriptor) {\n    if (isSymbol(name)) {\n      if (descriptor.enumerable) {\n        descriptor = $create(descriptor, {enumerable: {value: false}});\n      }\n      name = name[symbolInternalProperty];\n    }\n    $defineProperty(object, name, descriptor);\n    return object;\n  }\n  function polyfillObject(Object) {\n    $defineProperty(Object, 'defineProperty', {value: defineProperty});\n    $defineProperty(Object, 'getOwnPropertyNames', {value: getOwnPropertyNames});\n    $defineProperty(Object, 'getOwnPropertyDescriptor', {value: getOwnPropertyDescriptor});\n    $defineProperty(Object.prototype, 'hasOwnProperty', {value: hasOwnProperty});\n    Object.getOwnPropertySymbols = getOwnPropertySymbols;\n    function is(left, right) {\n      if (left === right)\n        return left !== 0 || 1 / left === 1 / right;\n      return left !== left && right !== right;\n    }\n    $defineProperty(Object, 'is', method(is));\n    function assign(target, source) {\n      var props = $getOwnPropertyNames(source);\n      var p,\n          length = props.length;\n      for (p = 0; p < length; p++) {\n        target[props[p]] = source[props[p]];\n      }\n      return target;\n    }\n    $defineProperty(Object, 'assign', method(assign));\n    function mixin(target, source) {\n      var props = $getOwnPropertyNames(source);\n      var p,\n          descriptor,\n          length = props.length;\n      for (p = 0; p < length; p++) {\n        descriptor = $getOwnPropertyDescriptor(source, props[p]);\n        $defineProperty(target, props[p], descriptor);\n      }\n      return target;\n    }\n    $defineProperty(Object, 'mixin', method(mixin));\n  }\n  function exportStar(object) {\n    for (var i = 1; i < arguments.length; i++) {\n      var names = $getOwnPropertyNames(arguments[i]);\n      for (var j = 0; j < names.length; j++) {\n        (function(mod, name) {\n          $defineProperty(object, name, {\n            get: function() {\n              return mod[name];\n            },\n            enumerable: true\n          });\n        })(arguments[i], names[j]);\n      }\n    }\n    return object;\n  }\n  function toObject(value) {\n    if (value == null)\n      throw $TypeError();\n    return $Object(value);\n  }\n  function spread() {\n    var rv = [],\n        k = 0;\n    for (var i = 0; i < arguments.length; i++) {\n      var valueToSpread = toObject(arguments[i]);\n      for (var j = 0; j < valueToSpread.length; j++) {\n        rv[k++] = valueToSpread[j];\n      }\n    }\n    return rv;\n  }\n  function getPropertyDescriptor(object, name) {\n    while (object !== null) {\n      var result = $getOwnPropertyDescriptor(object, name);\n      if (result)\n        return result;\n      object = $getPrototypeOf(object);\n    }\n    return undefined;\n  }\n  function superDescriptor(homeObject, name) {\n    var proto = $getPrototypeOf(homeObject);\n    if (!proto)\n      throw $TypeError('super is null');\n    return getPropertyDescriptor(proto, name);\n  }\n  function superCall(self, homeObject, name, args) {\n    var descriptor = superDescriptor(homeObject, name);\n    if (descriptor) {\n      if ('value' in descriptor)\n        return descriptor.value.apply(self, args);\n      if (descriptor.get)\n        return descriptor.get.call(self).apply(self, args);\n    }\n    throw $TypeError(\"super has no method '\" + name + \"'.\");\n  }\n  function superGet(self, homeObject, name) {\n    var descriptor = superDescriptor(homeObject, name);\n    if (descriptor) {\n      if (descriptor.get)\n        return descriptor.get.call(self);\n      else if ('value' in descriptor)\n        return descriptor.value;\n    }\n    return undefined;\n  }\n  function superSet(self, homeObject, name, value) {\n    var descriptor = superDescriptor(homeObject, name);\n    if (descriptor && descriptor.set) {\n      descriptor.set.call(self, value);\n      return;\n    }\n    throw $TypeError(\"super has no setter '\" + name + \"'.\");\n  }\n  function getDescriptors(object) {\n    var descriptors = {},\n        name,\n        names = $getOwnPropertyNames(object);\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      descriptors[name] = $getOwnPropertyDescriptor(object, name);\n    }\n    return descriptors;\n  }\n  function createClass(ctor, object, staticObject, superClass) {\n    $defineProperty(object, 'constructor', {\n      value: ctor,\n      configurable: true,\n      enumerable: false,\n      writable: true\n    });\n    if (arguments.length > 3) {\n      if (typeof superClass === 'function')\n        ctor.__proto__ = superClass;\n      ctor.prototype = $create(getProtoParent(superClass), getDescriptors(object));\n    } else {\n      ctor.prototype = object;\n    }\n    $defineProperty(ctor, 'prototype', {\n      configurable: false,\n      writable: false\n    });\n    return $defineProperties(ctor, getDescriptors(staticObject));\n  }\n  function getProtoParent(superClass) {\n    if (typeof superClass === 'function') {\n      var prototype = superClass.prototype;\n      if ($Object(prototype) === prototype || prototype === null)\n        return superClass.prototype;\n    }\n    if (superClass === null)\n      return null;\n    throw new TypeError();\n  }\n  function defaultSuperCall(self, homeObject, args) {\n    if ($getPrototypeOf(homeObject) !== null)\n      superCall(self, homeObject, 'constructor', args);\n  }\n  var ST_NEWBORN = 0;\n  var ST_EXECUTING = 1;\n  var ST_SUSPENDED = 2;\n  var ST_CLOSED = 3;\n  var END_STATE = -3;\n  function addIterator(object) {\n    return defineProperty(object, Symbol.iterator, nonEnum(function() {\n      return this;\n    }));\n  }\n  function GeneratorContext() {\n    this.state = 0;\n    this.GState = ST_NEWBORN;\n    this.storedException = undefined;\n    this.finallyFallThrough = undefined;\n    this.sent = undefined;\n    this.returnValue = undefined;\n    this.tryStack_ = [];\n  }\n  GeneratorContext.prototype = {\n    pushTry: function(catchState, finallyState) {\n      if (finallyState !== null) {\n        var finallyFallThrough = null;\n        for (var i = this.tryStack_.length - 1; i >= 0; i--) {\n          if (this.tryStack_[i].catch !== undefined) {\n            finallyFallThrough = this.tryStack_[i].catch;\n            break;\n          }\n        }\n        if (finallyFallThrough === null)\n          finallyFallThrough = -3;\n        this.tryStack_.push({\n          finally: finallyState,\n          finallyFallThrough: finallyFallThrough\n        });\n      }\n      if (catchState !== null) {\n        this.tryStack_.push({catch: catchState});\n      }\n    },\n    popTry: function() {\n      this.tryStack_.pop();\n    }\n  };\n  function getNextOrThrow(ctx, moveNext, action) {\n    return function(x) {\n      switch (ctx.GState) {\n        case ST_EXECUTING:\n          throw new Error((\"\\\"\" + action + \"\\\" on executing generator\"));\n        case ST_CLOSED:\n          throw new Error((\"\\\"\" + action + \"\\\" on closed generator\"));\n        case ST_NEWBORN:\n          if (action === 'throw') {\n            ctx.GState = ST_CLOSED;\n            throw x;\n          }\n          if (x !== undefined)\n            throw $TypeError('Sent value to newborn generator');\n        case ST_SUSPENDED:\n          ctx.GState = ST_EXECUTING;\n          ctx.action = action;\n          ctx.sent = x;\n          var value = moveNext(ctx);\n          var done = value === ctx;\n          if (done)\n            value = ctx.returnValue;\n          ctx.GState = done ? ST_CLOSED : ST_SUSPENDED;\n          return {\n            value: value,\n            done: done\n          };\n      }\n    };\n  }\n  function generatorWrap(innerFunction, self) {\n    var moveNext = getMoveNext(innerFunction, self);\n    var ctx = new GeneratorContext();\n    return addIterator({\n      next: getNextOrThrow(ctx, moveNext, 'next'),\n      throw: getNextOrThrow(ctx, moveNext, 'throw')\n    });\n  }\n  function AsyncFunctionContext() {\n    GeneratorContext.call(this);\n    this.err = undefined;\n    var ctx = this;\n    ctx.result = new Promise(function(resolve, reject) {\n      ctx.resolve = resolve;\n      ctx.reject = reject;\n    });\n  }\n  AsyncFunctionContext.prototype = Object.create(GeneratorContext.prototype);\n  function asyncWrap(innerFunction, self) {\n    var moveNext = getMoveNext(innerFunction, self);\n    var ctx = new AsyncFunctionContext();\n    ctx.createCallback = function(newState) {\n      return function(value) {\n        ctx.state = newState;\n        ctx.value = value;\n        moveNext(ctx);\n      };\n    };\n    ctx.createErrback = function(newState) {\n      return function(err) {\n        ctx.state = newState;\n        ctx.err = err;\n        moveNext(ctx);\n      };\n    };\n    moveNext(ctx);\n    return ctx.result;\n  }\n  function getMoveNext(innerFunction, self) {\n    return function(ctx) {\n      while (true) {\n        try {\n          return innerFunction.call(self, ctx);\n        } catch (ex) {\n          ctx.storedException = ex;\n          var last = ctx.tryStack_[ctx.tryStack_.length - 1];\n          if (!last) {\n            ctx.GState = ST_CLOSED;\n            ctx.state = END_STATE;\n            throw ex;\n          }\n          ctx.state = last.catch !== undefined ? last.catch : last.finally;\n          if (last.finallyFallThrough !== undefined)\n            ctx.finallyFallThrough = last.finallyFallThrough;\n        }\n      }\n    };\n  }\n  function setupGlobals(global) {\n    global.Symbol = Symbol;\n    polyfillObject(global.Object);\n  }\n  setupGlobals(global);\n  global.$traceurRuntime = {\n    asyncWrap: asyncWrap,\n    createClass: createClass,\n    defaultSuperCall: defaultSuperCall,\n    exportStar: exportStar,\n    generatorWrap: generatorWrap,\n    setProperty: setProperty,\n    setupGlobals: setupGlobals,\n    spread: spread,\n    superCall: superCall,\n    superGet: superGet,\n    superSet: superSet,\n    toObject: toObject,\n    toProperty: toProperty,\n    typeof: typeOf\n  };\n})(typeof global !== 'undefined' ? global : this);\n(function() {\n  function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n    var out = [];\n    if (opt_scheme) {\n      out.push(opt_scheme, ':');\n    }\n    if (opt_domain) {\n      out.push('//');\n      if (opt_userInfo) {\n        out.push(opt_userInfo, '@');\n      }\n      out.push(opt_domain);\n      if (opt_port) {\n        out.push(':', opt_port);\n      }\n    }\n    if (opt_path) {\n      out.push(opt_path);\n    }\n    if (opt_queryData) {\n      out.push('?', opt_queryData);\n    }\n    if (opt_fragment) {\n      out.push('#', opt_fragment);\n    }\n    return out.join('');\n  }\n  ;\n  var splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\\\?([^#]*))?' + '(?:#(.*))?' + '$');\n  var ComponentIndex = {\n    SCHEME: 1,\n    USER_INFO: 2,\n    DOMAIN: 3,\n    PORT: 4,\n    PATH: 5,\n    QUERY_DATA: 6,\n    FRAGMENT: 7\n  };\n  function split(uri) {\n    return (uri.match(splitRe));\n  }\n  function removeDotSegments(path) {\n    if (path === '/')\n      return '/';\n    var leadingSlash = path[0] === '/' ? '/' : '';\n    var trailingSlash = path.slice(-1) === '/' ? '/' : '';\n    var segments = path.split('/');\n    var out = [];\n    var up = 0;\n    for (var pos = 0; pos < segments.length; pos++) {\n      var segment = segments[pos];\n      switch (segment) {\n        case '':\n        case '.':\n          break;\n        case '..':\n          if (out.length)\n            out.pop();\n          else\n            up++;\n          break;\n        default:\n          out.push(segment);\n      }\n    }\n    if (!leadingSlash) {\n      while (up-- > 0) {\n        out.unshift('..');\n      }\n      if (out.length === 0)\n        out.push('.');\n    }\n    return leadingSlash + out.join('/') + trailingSlash;\n  }\n  function joinAndCanonicalizePath(parts) {\n    var path = parts[ComponentIndex.PATH] || '';\n    path = removeDotSegments(path.replace(/\\/\\//.g, '/'));\n    parts[ComponentIndex.PATH] = path;\n    return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);\n  }\n  function canonicalizeUrl(url) {\n    var parts = split(url);\n    return joinAndCanonicalizePath(parts);\n  }\n  function resolveUrl(base, url) {\n    var parts = split(url);\n    var baseParts = split(base);\n    if (parts[ComponentIndex.SCHEME]) {\n      return joinAndCanonicalizePath(parts);\n    } else {\n      parts[ComponentIndex.SCHEME] = baseParts[ComponentIndex.SCHEME];\n    }\n    for (var i = ComponentIndex.SCHEME; i <= ComponentIndex.PORT; i++) {\n      if (!parts[i]) {\n        parts[i] = baseParts[i];\n      }\n    }\n    if (parts[ComponentIndex.PATH][0] == '/') {\n      return joinAndCanonicalizePath(parts);\n    }\n    var path = baseParts[ComponentIndex.PATH];\n    var index = path.lastIndexOf('/');\n    path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];\n    parts[ComponentIndex.PATH] = path;\n    return joinAndCanonicalizePath(parts);\n  }\n  function isAbsolute(name) {\n    if (!name)\n      return false;\n    if (name[0] === '/')\n      return true;\n    var parts = split(name);\n    if (parts[ComponentIndex.SCHEME])\n      return true;\n    return false;\n  }\n  $traceurRuntime.canonicalizeUrl = canonicalizeUrl;\n  $traceurRuntime.isAbsolute = isAbsolute;\n  $traceurRuntime.removeDotSegments = removeDotSegments;\n  $traceurRuntime.resolveUrl = resolveUrl;\n})();\n(function(global) {\n  'use strict';\n  var $__2 = $traceurRuntime,\n      canonicalizeUrl = $__2.canonicalizeUrl,\n      resolveUrl = $__2.resolveUrl,\n      isAbsolute = $__2.isAbsolute;\n  var moduleInstantiators = Object.create(null);\n  var baseURL;\n  if (global.location && global.location.href)\n    baseURL = resolveUrl(global.location.href, './');\n  else\n    baseURL = '';\n  var UncoatedModuleEntry = function UncoatedModuleEntry(url, uncoatedModule) {\n    this.url = url;\n    this.value_ = uncoatedModule;\n  };\n  ($traceurRuntime.createClass)(UncoatedModuleEntry, {}, {});\n  var UncoatedModuleInstantiator = function UncoatedModuleInstantiator(url, func) {\n    $traceurRuntime.superCall(this, $UncoatedModuleInstantiator.prototype, \"constructor\", [url, null]);\n    this.func = func;\n  };\n  var $UncoatedModuleInstantiator = UncoatedModuleInstantiator;\n  ($traceurRuntime.createClass)(UncoatedModuleInstantiator, {getUncoatedModule: function() {\n      if (this.value_)\n        return this.value_;\n      return this.value_ = this.func.call(global);\n    }}, {}, UncoatedModuleEntry);\n  function getUncoatedModuleInstantiator(name) {\n    if (!name)\n      return;\n    var url = ModuleStore.normalize(name);\n    return moduleInstantiators[url];\n  }\n  ;\n  var moduleInstances = Object.create(null);\n  var liveModuleSentinel = {};\n  function Module(uncoatedModule) {\n    var isLive = arguments[1];\n    var coatedModule = Object.create(null);\n    Object.getOwnPropertyNames(uncoatedModule).forEach((function(name) {\n      var getter,\n          value;\n      if (isLive === liveModuleSentinel) {\n        var descr = Object.getOwnPropertyDescriptor(uncoatedModule, name);\n        if (descr.get)\n          getter = descr.get;\n      }\n      if (!getter) {\n        value = uncoatedModule[name];\n        getter = function() {\n          return value;\n        };\n      }\n      Object.defineProperty(coatedModule, name, {\n        get: getter,\n        enumerable: true\n      });\n    }));\n    Object.preventExtensions(coatedModule);\n    return coatedModule;\n  }\n  var ModuleStore = {\n    normalize: function(name, refererName, refererAddress) {\n      if (typeof name !== \"string\")\n        throw new TypeError(\"module name must be a string, not \" + typeof name);\n      if (isAbsolute(name))\n        return canonicalizeUrl(name);\n      if (/[^\\.]\\/\\.\\.\\//.test(name)) {\n        throw new Error('module name embeds /../: ' + name);\n      }\n      if (name[0] === '.' && refererName)\n        return resolveUrl(refererName, name);\n      return canonicalizeUrl(name);\n    },\n    get: function(normalizedName) {\n      var m = getUncoatedModuleInstantiator(normalizedName);\n      if (!m)\n        return undefined;\n      var moduleInstance = moduleInstances[m.url];\n      if (moduleInstance)\n        return moduleInstance;\n      moduleInstance = Module(m.getUncoatedModule(), liveModuleSentinel);\n      return moduleInstances[m.url] = moduleInstance;\n    },\n    set: function(normalizedName, module) {\n      normalizedName = String(normalizedName);\n      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, (function() {\n        return module;\n      }));\n      moduleInstances[normalizedName] = module;\n    },\n    get baseURL() {\n      return baseURL;\n    },\n    set baseURL(v) {\n      baseURL = String(v);\n    },\n    registerModule: function(name, func) {\n      var normalizedName = ModuleStore.normalize(name);\n      if (moduleInstantiators[normalizedName])\n        throw new Error('duplicate module named ' + normalizedName);\n      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, func);\n    },\n    bundleStore: Object.create(null),\n    register: function(name, deps, func) {\n      if (!deps || !deps.length) {\n        this.registerModule(name, func);\n      } else {\n        this.bundleStore[name] = {\n          deps: deps,\n          execute: func\n        };\n      }\n    },\n    getAnonymousModule: function(func) {\n      return new Module(func.call(global), liveModuleSentinel);\n    },\n    getForTesting: function(name) {\n      var $__0 = this;\n      if (!this.testingPrefix_) {\n        Object.keys(moduleInstances).some((function(key) {\n          var m = /(traceur@[^\\/]*\\/)/.exec(key);\n          if (m) {\n            $__0.testingPrefix_ = m[1];\n            return true;\n          }\n        }));\n      }\n      return this.get(this.testingPrefix_ + name);\n    }\n  };\n  ModuleStore.set('@traceur/src/runtime/ModuleStore', new Module({ModuleStore: ModuleStore}));\n  var setupGlobals = $traceurRuntime.setupGlobals;\n  $traceurRuntime.setupGlobals = function(global) {\n    setupGlobals(global);\n  };\n  $traceurRuntime.ModuleStore = ModuleStore;\n  global.System = {\n    register: ModuleStore.register.bind(ModuleStore),\n    get: ModuleStore.get,\n    set: ModuleStore.set,\n    normalize: ModuleStore.normalize\n  };\n  $traceurRuntime.getModuleImpl = function(name) {\n    var instantiator = getUncoatedModuleInstantiator(name);\n    return instantiator && instantiator.getUncoatedModule();\n  };\n})(typeof global !== 'undefined' ? global : this);\nSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/utils\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/utils\";\n  var toObject = $traceurRuntime.toObject;\n  function toUint32(x) {\n    return x | 0;\n  }\n  return {\n    get toObject() {\n      return toObject;\n    },\n    get toUint32() {\n      return toUint32;\n    }\n  };\n});\nSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/ArrayIterator\", [], function() {\n  \"use strict\";\n  var $__4;\n  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/ArrayIterator\";\n  var $__5 = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/utils\"),\n      toObject = $__5.toObject,\n      toUint32 = $__5.toUint32;\n  var ARRAY_ITERATOR_KIND_KEYS = 1;\n  var ARRAY_ITERATOR_KIND_VALUES = 2;\n  var ARRAY_ITERATOR_KIND_ENTRIES = 3;\n  var ArrayIterator = function ArrayIterator() {};\n  ($traceurRuntime.createClass)(ArrayIterator, ($__4 = {}, Object.defineProperty($__4, \"next\", {\n    value: function() {\n      var iterator = toObject(this);\n      var array = iterator.iteratorObject_;\n      if (!array) {\n        throw new TypeError('Object is not an ArrayIterator');\n      }\n      var index = iterator.arrayIteratorNextIndex_;\n      var itemKind = iterator.arrayIterationKind_;\n      var length = toUint32(array.length);\n      if (index >= length) {\n        iterator.arrayIteratorNextIndex_ = Infinity;\n        return createIteratorResultObject(undefined, true);\n      }\n      iterator.arrayIteratorNextIndex_ = index + 1;\n      if (itemKind == ARRAY_ITERATOR_KIND_VALUES)\n        return createIteratorResultObject(array[index], false);\n      if (itemKind == ARRAY_ITERATOR_KIND_ENTRIES)\n        return createIteratorResultObject([index, array[index]], false);\n      return createIteratorResultObject(index, false);\n    },\n    configurable: true,\n    enumerable: true,\n    writable: true\n  }), Object.defineProperty($__4, Symbol.iterator, {\n    value: function() {\n      return this;\n    },\n    configurable: true,\n    enumerable: true,\n    writable: true\n  }), $__4), {});\n  function createArrayIterator(array, kind) {\n    var object = toObject(array);\n    var iterator = new ArrayIterator;\n    iterator.iteratorObject_ = object;\n    iterator.arrayIteratorNextIndex_ = 0;\n    iterator.arrayIterationKind_ = kind;\n    return iterator;\n  }\n  function createIteratorResultObject(value, done) {\n    return {\n      value: value,\n      done: done\n    };\n  }\n  function entries() {\n    return createArrayIterator(this, ARRAY_ITERATOR_KIND_ENTRIES);\n  }\n  function keys() {\n    return createArrayIterator(this, ARRAY_ITERATOR_KIND_KEYS);\n  }\n  function values() {\n    return createArrayIterator(this, ARRAY_ITERATOR_KIND_VALUES);\n  }\n  return {\n    get entries() {\n      return entries;\n    },\n    get keys() {\n      return keys;\n    },\n    get values() {\n      return values;\n    }\n  };\n});\nSystem.register(\"traceur-runtime@0.0.25/node_modules/rsvp/lib/rsvp/asap\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.25/node_modules/rsvp/lib/rsvp/asap\";\n  var $__default = function asap(callback, arg) {\n    var length = queue.push([callback, arg]);\n    if (length === 1) {\n      scheduleFlush();\n    }\n  };\n  var browserGlobal = (typeof window !== 'undefined') ? window : {};\n  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\n  function useNextTick() {\n    return function() {\n      process.nextTick(flush);\n    };\n  }\n  function useMutationObserver() {\n    var iterations = 0;\n    var observer = new BrowserMutationObserver(flush);\n    var node = document.createTextNode('');\n    observer.observe(node, {characterData: true});\n    return function() {\n      node.data = (iterations = ++iterations % 2);\n    };\n  }\n  function useSetTimeout() {\n    return function() {\n      setTimeout(flush, 1);\n    };\n  }\n  var queue = [];\n  function flush() {\n    for (var i = 0; i < queue.length; i++) {\n      var tuple = queue[i];\n      var callback = tuple[0],\n          arg = tuple[1];\n      callback(arg);\n    }\n    queue = [];\n  }\n  var scheduleFlush;\n  if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n    scheduleFlush = useNextTick();\n  } else if (BrowserMutationObserver) {\n    scheduleFlush = useMutationObserver();\n  } else {\n    scheduleFlush = useSetTimeout();\n  }\n  return {get default() {\n      return $__default;\n    }};\n});\nSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/Promise\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/Promise\";\n  var async = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/node_modules/rsvp/lib/rsvp/asap\").default;\n  function isPromise(x) {\n    return x && typeof x === 'object' && x.status_ !== undefined;\n  }\n  function chain(promise) {\n    var onResolve = arguments[1] !== (void 0) ? arguments[1] : (function(x) {\n      return x;\n    });\n    var onReject = arguments[2] !== (void 0) ? arguments[2] : (function(e) {\n      throw e;\n    });\n    var deferred = getDeferred(promise.constructor);\n    switch (promise.status_) {\n      case undefined:\n        throw TypeError;\n      case 'pending':\n        promise.onResolve_.push([deferred, onResolve]);\n        promise.onReject_.push([deferred, onReject]);\n        break;\n      case 'resolved':\n        promiseReact(deferred, onResolve, promise.value_);\n        break;\n      case 'rejected':\n        promiseReact(deferred, onReject, promise.value_);\n        break;\n    }\n    return deferred.promise;\n  }\n  function getDeferred(C) {\n    var result = {};\n    result.promise = new C((function(resolve, reject) {\n      result.resolve = resolve;\n      result.reject = reject;\n    }));\n    return result;\n  }\n  var Promise = function Promise(resolver) {\n    var $__6 = this;\n    this.status_ = 'pending';\n    this.onResolve_ = [];\n    this.onReject_ = [];\n    resolver((function(x) {\n      promiseResolve($__6, x);\n    }), (function(r) {\n      promiseReject($__6, r);\n    }));\n  };\n  ($traceurRuntime.createClass)(Promise, {\n    catch: function(onReject) {\n      return this.then(undefined, onReject);\n    },\n    then: function() {\n      var onResolve = arguments[0] !== (void 0) ? arguments[0] : (function(x) {\n        return x;\n      });\n      var onReject = arguments[1];\n      var $__6 = this;\n      var constructor = this.constructor;\n      return chain(this, (function(x) {\n        x = promiseCoerce(constructor, x);\n        return x === $__6 ? onReject(new TypeError) : isPromise(x) ? x.then(onResolve, onReject) : onResolve(x);\n      }), onReject);\n    }\n  }, {\n    resolve: function(x) {\n      return new this((function(resolve, reject) {\n        resolve(x);\n      }));\n    },\n    reject: function(r) {\n      return new this((function(resolve, reject) {\n        reject(r);\n      }));\n    },\n    cast: function(x) {\n      if (x instanceof this)\n        return x;\n      if (isPromise(x)) {\n        var result = getDeferred(this);\n        chain(x, result.resolve, result.reject);\n        return result.promise;\n      }\n      return this.resolve(x);\n    },\n    all: function(values) {\n      var deferred = getDeferred(this);\n      var count = 0;\n      var resolutions = [];\n      try {\n        for (var i = 0; i < values.length; i++) {\n          ++count;\n          this.cast(values[i]).then(function(i, x) {\n            resolutions[i] = x;\n            if (--count === 0)\n              deferred.resolve(resolutions);\n          }.bind(undefined, i), (function(r) {\n            if (count > 0)\n              count = 0;\n            deferred.reject(r);\n          }));\n        }\n        if (count === 0)\n          deferred.resolve(resolutions);\n      } catch (e) {\n        deferred.reject(e);\n      }\n      return deferred.promise;\n    },\n    race: function(values) {\n      var deferred = getDeferred(this);\n      try {\n        for (var i = 0; i < values.length; i++) {\n          this.cast(values[i]).then((function(x) {\n            deferred.resolve(x);\n          }), (function(r) {\n            deferred.reject(r);\n          }));\n        }\n      } catch (e) {\n        deferred.reject(e);\n      }\n      return deferred.promise;\n    }\n  });\n  function promiseResolve(promise, x) {\n    promiseDone(promise, 'resolved', x, promise.onResolve_);\n  }\n  function promiseReject(promise, r) {\n    promiseDone(promise, 'rejected', r, promise.onReject_);\n  }\n  function promiseDone(promise, status, value, reactions) {\n    if (promise.status_ !== 'pending')\n      return;\n    for (var i = 0; i < reactions.length; i++) {\n      promiseReact(reactions[i][0], reactions[i][1], value);\n    }\n    promise.status_ = status;\n    promise.value_ = value;\n    promise.onResolve_ = promise.onReject_ = undefined;\n  }\n  function promiseReact(deferred, handler, x) {\n    async((function() {\n      try {\n        var y = handler(x);\n        if (y === deferred.promise)\n          throw new TypeError;\n        else if (isPromise(y))\n          chain(y, deferred.resolve, deferred.reject);\n        else\n          deferred.resolve(y);\n      } catch (e) {\n        deferred.reject(e);\n      }\n    }));\n  }\n  var thenableSymbol = '@@thenable';\n  function promiseCoerce(constructor, x) {\n    if (isPromise(x)) {\n      return x;\n    } else if (x && typeof x.then === 'function') {\n      var p = x[thenableSymbol];\n      if (p) {\n        return p;\n      } else {\n        var deferred = getDeferred(constructor);\n        x[thenableSymbol] = deferred.promise;\n        try {\n          x.then(deferred.resolve, deferred.reject);\n        } catch (e) {\n          deferred.reject(e);\n        }\n        return deferred.promise;\n      }\n    } else {\n      return x;\n    }\n  }\n  return {get Promise() {\n      return Promise;\n    }};\n});\nSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/String\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/String\";\n  var $toString = Object.prototype.toString;\n  var $indexOf = String.prototype.indexOf;\n  var $lastIndexOf = String.prototype.lastIndexOf;\n  function startsWith(search) {\n    var string = String(this);\n    if (this == null || $toString.call(search) == '[object RegExp]') {\n      throw TypeError();\n    }\n    var stringLength = string.length;\n    var searchString = String(search);\n    var searchLength = searchString.length;\n    var position = arguments.length > 1 ? arguments[1] : undefined;\n    var pos = position ? Number(position) : 0;\n    if (isNaN(pos)) {\n      pos = 0;\n    }\n    var start = Math.min(Math.max(pos, 0), stringLength);\n    return $indexOf.call(string, searchString, pos) == start;\n  }\n  function endsWith(search) {\n    var string = String(this);\n    if (this == null || $toString.call(search) == '[object RegExp]') {\n      throw TypeError();\n    }\n    var stringLength = string.length;\n    var searchString = String(search);\n    var searchLength = searchString.length;\n    var pos = stringLength;\n    if (arguments.length > 1) {\n      var position = arguments[1];\n      if (position !== undefined) {\n        pos = position ? Number(position) : 0;\n        if (isNaN(pos)) {\n          pos = 0;\n        }\n      }\n    }\n    var end = Math.min(Math.max(pos, 0), stringLength);\n    var start = end - searchLength;\n    if (start < 0) {\n      return false;\n    }\n    return $lastIndexOf.call(string, searchString, start) == start;\n  }\n  function contains(search) {\n    if (this == null) {\n      throw TypeError();\n    }\n    var string = String(this);\n    var stringLength = string.length;\n    var searchString = String(search);\n    var searchLength = searchString.length;\n    var position = arguments.length > 1 ? arguments[1] : undefined;\n    var pos = position ? Number(position) : 0;\n    if (isNaN(pos)) {\n      pos = 0;\n    }\n    var start = Math.min(Math.max(pos, 0), stringLength);\n    return $indexOf.call(string, searchString, pos) != -1;\n  }\n  function repeat(count) {\n    if (this == null) {\n      throw TypeError();\n    }\n    var string = String(this);\n    var n = count ? Number(count) : 0;\n    if (isNaN(n)) {\n      n = 0;\n    }\n    if (n < 0 || n == Infinity) {\n      throw RangeError();\n    }\n    if (n == 0) {\n      return '';\n    }\n    var result = '';\n    while (n--) {\n      result += string;\n    }\n    return result;\n  }\n  function codePointAt(position) {\n    if (this == null) {\n      throw TypeError();\n    }\n    var string = String(this);\n    var size = string.length;\n    var index = position ? Number(position) : 0;\n    if (isNaN(index)) {\n      index = 0;\n    }\n    if (index < 0 || index >= size) {\n      return undefined;\n    }\n    var first = string.charCodeAt(index);\n    var second;\n    if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {\n      second = string.charCodeAt(index + 1);\n      if (second >= 0xDC00 && second <= 0xDFFF) {\n        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n      }\n    }\n    return first;\n  }\n  function raw(callsite) {\n    var raw = callsite.raw;\n    var len = raw.length >>> 0;\n    if (len === 0)\n      return '';\n    var s = '';\n    var i = 0;\n    while (true) {\n      s += raw[i];\n      if (i + 1 === len)\n        return s;\n      s += arguments[++i];\n    }\n  }\n  function fromCodePoint() {\n    var codeUnits = [];\n    var floor = Math.floor;\n    var highSurrogate;\n    var lowSurrogate;\n    var index = -1;\n    var length = arguments.length;\n    if (!length) {\n      return '';\n    }\n    while (++index < length) {\n      var codePoint = Number(arguments[index]);\n      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {\n        throw RangeError('Invalid code point: ' + codePoint);\n      }\n      if (codePoint <= 0xFFFF) {\n        codeUnits.push(codePoint);\n      } else {\n        codePoint -= 0x10000;\n        highSurrogate = (codePoint >> 10) + 0xD800;\n        lowSurrogate = (codePoint % 0x400) + 0xDC00;\n        codeUnits.push(highSurrogate, lowSurrogate);\n      }\n    }\n    return String.fromCharCode.apply(null, codeUnits);\n  }\n  return {\n    get startsWith() {\n      return startsWith;\n    },\n    get endsWith() {\n      return endsWith;\n    },\n    get contains() {\n      return contains;\n    },\n    get repeat() {\n      return repeat;\n    },\n    get codePointAt() {\n      return codePointAt;\n    },\n    get raw() {\n      return raw;\n    },\n    get fromCodePoint() {\n      return fromCodePoint;\n    }\n  };\n});\nSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/polyfills\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/polyfills\";\n  var Promise = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/Promise\").Promise;\n  var $__9 = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/String\"),\n      codePointAt = $__9.codePointAt,\n      contains = $__9.contains,\n      endsWith = $__9.endsWith,\n      fromCodePoint = $__9.fromCodePoint,\n      repeat = $__9.repeat,\n      raw = $__9.raw,\n      startsWith = $__9.startsWith;\n  var $__9 = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/ArrayIterator\"),\n      entries = $__9.entries,\n      keys = $__9.keys,\n      values = $__9.values;\n  function maybeDefineMethod(object, name, value) {\n    if (!(name in object)) {\n      Object.defineProperty(object, name, {\n        value: value,\n        configurable: true,\n        enumerable: false,\n        writable: true\n      });\n    }\n  }\n  function maybeAddFunctions(object, functions) {\n    for (var i = 0; i < functions.length; i += 2) {\n      var name = functions[i];\n      var value = functions[i + 1];\n      maybeDefineMethod(object, name, value);\n    }\n  }\n  function polyfillPromise(global) {\n    if (!global.Promise)\n      global.Promise = Promise;\n  }\n  function polyfillString(String) {\n    maybeAddFunctions(String.prototype, ['codePointAt', codePointAt, 'contains', contains, 'endsWith', endsWith, 'startsWith', startsWith, 'repeat', repeat]);\n    maybeAddFunctions(String, ['fromCodePoint', fromCodePoint, 'raw', raw]);\n  }\n  function polyfillArray(Array, Symbol) {\n    maybeAddFunctions(Array.prototype, ['entries', entries, 'keys', keys, 'values', values]);\n    if (Symbol && Symbol.iterator) {\n      Object.defineProperty(Array.prototype, Symbol.iterator, {\n        value: values,\n        configurable: true,\n        enumerable: false,\n        writable: true\n      });\n    }\n  }\n  function polyfill(global) {\n    polyfillPromise(global);\n    polyfillString(global.String);\n    polyfillArray(global.Array, global.Symbol);\n  }\n  polyfill(this);\n  var setupGlobals = $traceurRuntime.setupGlobals;\n  $traceurRuntime.setupGlobals = function(global) {\n    setupGlobals(global);\n    polyfill(global);\n  };\n  return {};\n});\nSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfill-import\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfill-import\";\n  var $__11 = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/polyfills\");\n  return {};\n});\nSystem.get(\"traceur-runtime@0.0.25/src/runtime/polyfill-import\" + '');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../pink/~/traceur/bin/traceur-runtime.js\n ** module id = 13\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"9ac7e2ff6b9792291e65269b982efa35.otf\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../pink/css/fonts/Helvetica/HelveticaNeueLTStd-Bd.otf\n ** module id = 14\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"09ad3649cefc511e2e20b98991116a59.otf\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../pink/css/fonts/Helvetica/HelveticaNeueLTStd-BdIt.otf\n ** module id = 15\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"f0d7d673ef06ec9cf090dc00572d63e4.otf\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../pink/css/fonts/Helvetica/HelveticaNeueLTStd-Md.otf\n ** module id = 16\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"f02f3b1af0eda2c88d9a7ae67234c564.otf\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../pink/css/fonts/Helvetica/HelveticaNeueLTStd-MdIt.otf\n ** module id = 17\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"819f56653a4197a7959c41ddfc8ff69b.ttf\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../pink/css/fonts/Inconsolata/Inconsolata-Bold.ttf\n ** module id = 18\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"9ac6e3d2a7fb76468bd417ea40b6f8c4.ttf\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../pink/css/fonts/Inconsolata/Inconsolata-Regular.ttf\n ** module id = 19\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"3bb8cd188e88dfe3b75c26c86dae0d79.svg\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../pink/css/doge.svg\n ** module id = 20\n ** module chunks = 0\n **/","module.exports = __webpack_public_path__ + \"e17c44b2d6689463899b823f3201f837.svg\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../pink/css/red-doge.svg\n ** module id = 21\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../pink/~/webpack/~/node-libs-browser/~/process/browser.js\n ** module id = 22\n ** module chunks = 0\n **/"],"sourceRoot":""}